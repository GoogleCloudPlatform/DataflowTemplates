{
  "kind": "discovery#restDescription",
  "discoveryVersion": "v1",
  "id": "servicemanagement:v1",
  "name": "servicemanagement",
  "version": "v1",
  "revision": "0",
  "title": "Google Service Management API",
  "description": "The service management API for Google Cloud Platform",
  "ownerDomain": "google.com",
  "ownerName": "Google",
  "icons": {
    "x16": "http://www.google.com/images/icons/product/search-16.gif",
    "x32": "http://www.google.com/images/icons/product/search-32.gif"
   },
  "documentationLink": "https://cloud.google.com/service-management/",
  "protocol": "rest",
  "rootUrl": "https://servicemanagement.googleapis.com/",
  "servicePath": "",
  "baseUrl": "https://servicemanagement.googleapis.com/",
  "batchPath": "batch",
  "parameters": {
    "access_token": {
      "type": "string",
      "description": "OAuth access token.",
      "location": "query"
    },
    "alt": {
      "type": "string",
      "description": "Data format for response.",
      "default": "json",
      "enum": [
        "json",
        "media",
        "proto"
      ],
      "enumDescriptions": [
        "Responses with Content-Type of application/json",
        "Media download with context-dependent Content-Type",
        "Responses with Content-Type of application/x-protobuf"
      ],
      "location": "query"
    },
    "bearer_token": {
      "type": "string",
      "description": "OAuth bearer token.",
      "location": "query"
    },
    "callback": {
      "type": "string",
      "description": "JSONP",
      "location": "query"
    },
    "fields": {
      "type": "string",
      "description": "Selector specifying which fields to include in a partial response.",
      "location": "query"
    },
    "key": {
      "type": "string",
      "description": "API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token.",
      "location": "query"
    },
    "oauth_token": {
      "type": "string",
      "description": "OAuth 2.0 token for the current user.",
      "location": "query"
    },
    "pp": {
      "type": "boolean",
      "description": "Pretty-print response.",
      "default": "true",
      "location": "query"
    },
    "prettyPrint": {
      "type": "boolean",
      "description": "Returns response with indentations and line breaks.",
      "default": "true",
      "location": "query"
    },
    "quotaUser": {
      "type": "string",
      "description": "Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters.",
      "location": "query"
    },
    "upload_protocol": {
      "type": "string",
      "description": "Upload protocol for media (e.g. \"raw\", \"multipart\").",
      "location": "query"
    },
    "uploadType": {
      "type": "string",
      "description": "Legacy upload protocol for media (e.g. \"media\", \"multipart\").",
      "location": "query"
    },
    "$.xgafv": {
      "type": "string",
      "description": "V1 error format.",
      "enum": [
        "1",
        "2"
      ],
      "enumDescriptions": [
        "v1 error format",
        "v2 error format"
      ],
      "location": "query"
    }
  },
  "auth": {
    "oauth2": {
      "scopes": {
        "https://www.googleapis.com/auth/cloud-platform": {
          "description": "View and manage your data across Google Cloud Platform services"
        },
        "https://www.googleapis.com/auth/service.management": {
          "description": "Manage your Google API service configuration"
        }
      }
    }
  },
  "schemas": {
    "ListServicesResponse": {
      "id": "ListServicesResponse",
      "description": "Response message for `ListServices` method.",
      "type": "object",
      "properties": {
        "services": {
          "description": "The results of the query.",
          "type": "array",
          "items": {
            "$ref": "ManagedService"
          }
        },
        "nextPageToken": {
          "description": "Token that can be passed to `ListServices` to resume a paginated query.",
          "type": "string"
        }
      }
    },
    "ManagedService": {
      "id": "ManagedService",
      "description": "The full representation of an API Service that is managed by the\n`ServiceManager` API.  Includes both the service configuration, as well as\nother control plane deployment related information.",
      "type": "object",
      "properties": {
        "serviceName": {
          "description": "The name of the service.  See the `ServiceManager` overview for naming\nrequirements.  This name must match `google.api.Service.name` in the\n`service_config` field.",
          "type": "string"
        },
        "producerProjectId": {
          "description": "ID of the project that produces and owns this service.",
          "type": "string"
        },
        "generation": {
          "description": "A server-assigned monotonically increasing number that changes whenever a\nmutation is made to the `ManagedService` or any of its components via the\n`ServiceManager` API.",
          "type": "string",
          "format": "int64"
        },
        "serviceConfig": {
          "description": "The service's generated configuration.",
          "$ref": "Service"
        },
        "configSource": {
          "description": "User-supplied source configuration for the service. This is distinct from\nthe generated configuration provided in `google.api.Service`.\nThis is NOT populated on GetService calls at the moment.\nNOTE: Any upsert operation that contains both a service_config\nand a config_source is considered invalid and will result in\nan error being returned.",
          "$ref": "ConfigSource"
        },
        "operations": {
          "description": "Read-only view of pending operations affecting this resource, if requested.",
          "type": "array",
          "items": {
            "$ref": "Operation"
          }
        },
        "projectSettings": {
          "description": "Read-only view of settings for a particular consumer project, if requested.",
          "$ref": "ProjectSettings"
        }
      }
    },
    "Service": {
      "id": "Service",
      "description": "`Service` is the root object of the configuration schema. It\ndescribes basic information like the name of the service and the\nexposed API interfaces, and delegates other aspects to configuration\nsub-sections.\n\nExample:\n\n    type: google.api.Service\n    config_version: 1\n    name: calendar.googleapis.com\n    title: Google Calendar API\n    apis:\n    - name: google.calendar.Calendar\n    backend:\n      rules:\n      - selector: \"*\"\n        address: calendar.example.com",
      "type": "object",
      "properties": {
        "configVersion": {
          "description": "The version of the service configuration. The config version may\ninfluence interpretation of the configuration, for example, to\ndetermine defaults. This is documented together with applicable\noptions. The current default for the config version itself is `3`.",
          "type": "integer",
          "format": "uint32"
        },
        "name": {
          "description": "The DNS address at which this service is available,\ne.g. `calendar.googleapis.com`.",
          "type": "string"
        },
        "id": {
          "description": "A unique ID for a specific instance of this message, typically assigned\nby the client for tracking purpose. If empty, the server may choose to\ngenerate one instead.",
          "type": "string"
        },
        "title": {
          "description": "The product title associated with this service.",
          "type": "string"
        },
        "producerProjectId": {
          "description": "The id of the Google developer project that owns the service.\nMembers of this project can manage the service configuration,\nmanage consumption of the service, etc.",
          "type": "string"
        },
        "apis": {
          "description": "A list of API interfaces exported by this service. Only the `name` field\nof the google.protobuf.Api needs to be provided by the configuration\nauthor, as the remaining fields will be derived from the IDL during the\nnormalization process. It is an error to specify an API interface here\nwhich cannot be resolved against the associated IDL files.",
          "type": "array",
          "items": {
            "$ref": "Api"
          }
        },
        "types": {
          "description": "A list of all proto message types included in this API service.\nTypes referenced directly or indirectly by the `apis` are\nautomatically included.  Messages which are not referenced but\nshall be included, such as types used by the `google.protobuf.Any` type,\nshould be listed here by name. Example:\n\n    types:\n    - name: google.protobuf.Int32",
          "type": "array",
          "items": {
            "$ref": "Type"
          }
        },
        "enums": {
          "description": "A list of all enum types included in this API service.  Enums\nreferenced directly or indirectly by the `apis` are automatically\nincluded.  Enums which are not referenced but shall be included\nshould be listed here by name. Example:\n\n    enums:\n    - name: google.someapi.v1.SomeEnum",
          "type": "array",
          "items": {
            "$ref": "Enum"
          }
        },
        "documentation": {
          "description": "Additional API documentation.",
          "$ref": "Documentation"
        },
        "visibility": {
          "description": "API visibility configuration.",
          "$ref": "Visibility"
        },
        "backend": {
          "description": "API backend configuration.",
          "$ref": "Backend"
        },
        "http": {
          "description": "HTTP configuration.",
          "$ref": "Http"
        },
        "quota": {
          "description": "Quota configuration.",
          "$ref": "Quota"
        },
        "authentication": {
          "description": "Auth configuration.",
          "$ref": "Authentication"
        },
        "context": {
          "description": "Context configuration.",
          "$ref": "Context"
        },
        "usage": {
          "description": "Configuration controlling usage of this service.",
          "$ref": "Usage"
        },
        "customError": {
          "description": "Custom error configuration.",
          "$ref": "CustomError"
        },
        "projectProperties": {
          "description": "Configuration of per-consumer project properties.",
          "$ref": "ProjectProperties"
        },
        "control": {
          "description": "Configuration for the service control plane.",
          "$ref": "Control"
        },
        "logs": {
          "description": "Defines the logs used by this service.",
          "type": "array",
          "items": {
            "$ref": "LogDescriptor"
          }
        },
        "metrics": {
          "description": "Defines the metrics used by this service.",
          "type": "array",
          "items": {
            "$ref": "MetricDescriptor"
          }
        },
        "monitoredResources": {
          "description": "Defines the monitored resources used by this service. This is required\nby the Service.monitoring and Service.logging configurations.\n",
          "type": "array",
          "items": {
            "$ref": "MonitoredResourceDescriptor"
          }
        },
        "billing": {
          "description": "Billing configuration of the service.",
          "$ref": "Billing"
        },
        "logging": {
          "description": "Logging configuration of the service.",
          "$ref": "Logging"
        },
        "monitoring": {
          "description": "Monitoring configuration of the service.",
          "$ref": "Monitoring"
        },
        "systemParameters": {
          "description": "Configuration for system parameters.",
          "$ref": "SystemParameters"
        },
        "systemTypes": {
          "description": "A list of all proto message types included in this API service.\nIt serves similar purpose as [google.api.Service.types], except that\nthese types are not needed by user-defined APIs. Therefore, they will not\nshow up in the generated discovery doc. This field should only be used\nto define system APIs in ESF.",
          "type": "array",
          "items": {
            "$ref": "Type"
          }
        }
      }
    },
    "Api": {
      "id": "Api",
      "description": "Api is a light-weight descriptor for a protocol buffer service.",
      "type": "object",
      "properties": {
        "name": {
          "description": "The fully qualified name of this api, including package name\nfollowed by the api's simple name.",
          "type": "string"
        },
        "methods": {
          "description": "The methods of this api, in unspecified order.",
          "type": "array",
          "items": {
            "$ref": "Method"
          }
        },
        "options": {
          "description": "Any metadata attached to the API.",
          "type": "array",
          "items": {
            "$ref": "Option"
          }
        },
        "version": {
          "description": "A version string for this api. If specified, must have the form\n`major-version.minor-version`, as in `1.10`. If the minor version\nis omitted, it defaults to zero. If the entire version field is\nempty, the major version is derived from the package name, as\noutlined below. If the field is not empty, the version in the\npackage name will be verified to be consistent with what is\nprovided here.\n\nThe versioning schema uses [semantic\nversioning](http:\/\/semver.org) where the major version number\nindicates a breaking change and the minor version an additive,\nnon-breaking change. Both version numbers are signals to users\nwhat to expect from different versions, and should be carefully\nchosen based on the product plan.\n\nThe major version is also reflected in the package name of the\nAPI, which must end in `v<major-version>`, as in\n`google.feature.v1`. For major versions 0 and 1, the suffix can\nbe omitted. Zero major versions must only be used for\nexperimental, none-GA apis.\n\n",
          "type": "string"
        },
        "sourceContext": {
          "description": "Source context for the protocol buffer service represented by this\nmessage.",
          "$ref": "SourceContext"
        },
        "mixins": {
          "description": "Included APIs. See Mixin.",
          "type": "array",
          "items": {
            "$ref": "Mixin"
          }
        },
        "syntax": {
          "description": "The source syntax of the service.",
          "enumDescriptions": [
            "Syntax `proto2`.",
            "Syntax `proto3`."
          ],
          "type": "string",
          "enum": [
            "SYNTAX_PROTO2",
            "SYNTAX_PROTO3"
          ]
        }
      }
    },
    "Method": {
      "id": "Method",
      "description": "Method represents a method of an api.",
      "type": "object",
      "properties": {
        "name": {
          "description": "The simple name of this method.",
          "type": "string"
        },
        "requestTypeUrl": {
          "description": "A URL of the input message type.",
          "type": "string"
        },
        "requestStreaming": {
          "description": "If true, the request is streamed.",
          "type": "boolean"
        },
        "responseTypeUrl": {
          "description": "The URL of the output message type.",
          "type": "string"
        },
        "responseStreaming": {
          "description": "If true, the response is streamed.",
          "type": "boolean"
        },
        "options": {
          "description": "Any metadata attached to the method.",
          "type": "array",
          "items": {
            "$ref": "Option"
          }
        },
        "syntax": {
          "description": "The source syntax of this method.",
          "enumDescriptions": [
            "Syntax `proto2`.",
            "Syntax `proto3`."
          ],
          "type": "string",
          "enum": [
            "SYNTAX_PROTO2",
            "SYNTAX_PROTO3"
          ]
        }
      }
    },
    "Option": {
      "id": "Option",
      "description": "A protocol buffer option, which can be attached to a message, field,\nenumeration, etc.",
      "type": "object",
      "properties": {
        "name": {
          "description": "The option's name. For example, `\"java_package\"`.",
          "type": "string"
        },
        "value": {
          "description": "The option's value. For example, `\"com.google.protobuf\"`.",
          "type": "object",
          "additionalProperties": {
            "type": "any",
            "description": "Properties of the object. Contains field @type with type URL."
          }
        }
      }
    },
    "SourceContext": {
      "id": "SourceContext",
      "description": "`SourceContext` represents information about the source of a\nprotobuf element, like the file in which it is defined.",
      "type": "object",
      "properties": {
        "fileName": {
          "description": "The path-qualified name of the .proto file that contained the associated\nprotobuf element.  For example: `\"google\/protobuf\/source_context.proto\"`.",
          "type": "string"
        }
      }
    },
    "Mixin": {
      "id": "Mixin",
      "description": "Declares an API to be included in this API. The including API must\nredeclare all the methods from the included API, but documentation\nand options are inherited as follows:\n\n- If after comment and whitespace stripping, the documentation\n  string of the redeclared method is empty, it will be inherited\n  from the original method.\n\n- Each annotation belonging to the service config (http,\n  visibility) which is not set in the redeclared method will be\n  inherited.\n\n- If an http annotation is inherited, the path pattern will be\n  modified as follows. Any version prefix will be replaced by the\n  version of the including API plus the root path if specified.\n\nExample of a simple mixin:\n\n    package google.acl.v1;\n    service AccessControl {\n      \/\/ Get the underlying ACL object.\n      rpc GetAcl(GetAclRequest) returns (Acl) {\n        option (google.api.http).get = \"\/v1\/{resource=**}:getAcl\";\n      }\n    }\n\n    package google.storage.v2;\n    service Storage {\n      \/\/       rpc GetAcl(GetAclRequest) returns (Acl);\n\n      \/\/ Get a data record.\n      rpc GetData(GetDataRequest) returns (Data) {\n        option (google.api.http).get = \"\/v2\/{resource=**}\";\n      }\n    }\n\nExample of a mixin configuration:\n\n    apis:\n    - name: google.storage.v2.Storage\n      mixins:\n      - name: google.acl.v1.AccessControl\n\nThe mixin construct implies that all methods in `AccessControl` are\nalso declared with same name and request\/response types in\n`Storage`. A documentation generator or annotation processor will\nsee the effective `Storage.GetAcl` method after inherting\ndocumentation and annotations as follows:\n\n    service Storage {\n      \/\/ Get the underlying ACL object.\n      rpc GetAcl(GetAclRequest) returns (Acl) {\n        option (google.api.http).get = \"\/v2\/{resource=**}:getAcl\";\n      }\n      ...\n    }\n\nNote how the version in the path pattern changed from `v1` to `v2`.\n\nIf the `root` field in the mixin is specified, it should be a\nrelative path under which inherited HTTP paths are placed. Example:\n\n    apis:\n    - name: google.storage.v2.Storage\n      mixins:\n      - name: google.acl.v1.AccessControl\n        root: acls\n\nThis implies the following inherited HTTP annotation:\n\n    service Storage {\n      \/\/ Get the underlying ACL object.\n      rpc GetAcl(GetAclRequest) returns (Acl) {\n        option (google.api.http).get = \"\/v2\/acls\/{resource=**}:getAcl\";\n      }\n      ...\n    }",
      "type": "object",
      "properties": {
        "name": {
          "description": "The fully qualified name of the API which is included.",
          "type": "string"
        },
        "root": {
          "description": "If non-empty specifies a path under which inherited HTTP paths\nare rooted.",
          "type": "string"
        }
      }
    },
    "Type": {
      "id": "Type",
      "description": "A protocol buffer message type.",
      "type": "object",
      "properties": {
        "name": {
          "description": "The fully qualified message name.",
          "type": "string"
        },
        "fields": {
          "description": "The list of fields.",
          "type": "array",
          "items": {
            "$ref": "Field"
          }
        },
        "oneofs": {
          "description": "The list of types appearing in `oneof` definitions in this type.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "options": {
          "description": "The protocol buffer options.",
          "type": "array",
          "items": {
            "$ref": "Option"
          }
        },
        "sourceContext": {
          "description": "The source context.",
          "$ref": "SourceContext"
        },
        "syntax": {
          "description": "The source syntax.",
          "enumDescriptions": [
            "Syntax `proto2`.",
            "Syntax `proto3`."
          ],
          "type": "string",
          "enum": [
            "SYNTAX_PROTO2",
            "SYNTAX_PROTO3"
          ]
        }
      }
    },
    "Field": {
      "id": "Field",
      "description": "A single field of a message type.",
      "type": "object",
      "properties": {
        "kind": {
          "description": "The field type.",
          "enumDescriptions": [
            "Field type unknown.",
            "Field type double.",
            "Field type float.",
            "Field type int64.",
            "Field type uint64.",
            "Field type int32.",
            "Field type fixed64.",
            "Field type fixed32.",
            "Field type bool.",
            "Field type string.",
            "Field type group. Proto2 syntax only, and deprecated.",
            "Field type message.",
            "Field type bytes.",
            "Field type uint32.",
            "Field type enum.",
            "Field type sfixed32.",
            "Field type sfixed64.",
            "Field type sint32.",
            "Field type sint64."
          ],
          "type": "string",
          "enum": [
            "TYPE_UNKNOWN",
            "TYPE_DOUBLE",
            "TYPE_FLOAT",
            "TYPE_INT64",
            "TYPE_UINT64",
            "TYPE_INT32",
            "TYPE_FIXED64",
            "TYPE_FIXED32",
            "TYPE_BOOL",
            "TYPE_STRING",
            "TYPE_GROUP",
            "TYPE_MESSAGE",
            "TYPE_BYTES",
            "TYPE_UINT32",
            "TYPE_ENUM",
            "TYPE_SFIXED32",
            "TYPE_SFIXED64",
            "TYPE_SINT32",
            "TYPE_SINT64"
          ]
        },
        "cardinality": {
          "description": "The field cardinality.",
          "enumDescriptions": [
            "For fields with unknown cardinality.",
            "For optional fields.",
            "For required fields. Proto2 syntax only.",
            "For repeated fields."
          ],
          "type": "string",
          "enum": [
            "CARDINALITY_UNKNOWN",
            "CARDINALITY_OPTIONAL",
            "CARDINALITY_REQUIRED",
            "CARDINALITY_REPEATED"
          ]
        },
        "number": {
          "description": "The field number.",
          "type": "integer",
          "format": "int32"
        },
        "name": {
          "description": "The field name.",
          "type": "string"
        },
        "typeUrl": {
          "description": "The field type URL, without the scheme, for message or enumeration\ntypes. Example: `\"type.googleapis.com\/google.protobuf.Timestamp\"`.",
          "type": "string"
        },
        "oneofIndex": {
          "description": "The index of the field type in `Type.oneofs`, for message or enumeration\ntypes. The first type has index 1; zero means the type is not in the list.",
          "type": "integer",
          "format": "int32"
        },
        "packed": {
          "description": "Whether to use alternative packed wire representation.",
          "type": "boolean"
        },
        "options": {
          "description": "The protocol buffer options.",
          "type": "array",
          "items": {
            "$ref": "Option"
          }
        },
        "jsonName": {
          "description": "The field JSON name.",
          "type": "string"
        },
        "defaultValue": {
          "description": "The string value of the default value of this field. Proto2 syntax only.",
          "type": "string"
        }
      }
    },
    "Enum": {
      "id": "Enum",
      "description": "Enum type definition.",
      "type": "object",
      "properties": {
        "name": {
          "description": "Enum type name.",
          "type": "string"
        },
        "enumvalue": {
          "description": "Enum value definitions.",
          "type": "array",
          "items": {
            "$ref": "EnumValue"
          }
        },
        "options": {
          "description": "Protocol buffer options.",
          "type": "array",
          "items": {
            "$ref": "Option"
          }
        },
        "sourceContext": {
          "description": "The source context.",
          "$ref": "SourceContext"
        },
        "syntax": {
          "description": "The source syntax.",
          "enumDescriptions": [
            "Syntax `proto2`.",
            "Syntax `proto3`."
          ],
          "type": "string",
          "enum": [
            "SYNTAX_PROTO2",
            "SYNTAX_PROTO3"
          ]
        }
      }
    },
    "EnumValue": {
      "id": "EnumValue",
      "description": "Enum value definition.",
      "type": "object",
      "properties": {
        "name": {
          "description": "Enum value name.",
          "type": "string"
        },
        "number": {
          "description": "Enum value number.",
          "type": "integer",
          "format": "int32"
        },
        "options": {
          "description": "Protocol buffer options.",
          "type": "array",
          "items": {
            "$ref": "Option"
          }
        }
      }
    },
    "Documentation": {
      "id": "Documentation",
      "description": "`Documentation` provides the information for describing a service.\n\nExample:\n<pre><code>documentation:\n  summary: >\n    The Google Calendar API gives access\n    to most calendar features.\n  pages:\n  - name: Overview\n    content: &#40;== include google\/foo\/overview.md ==&#41;\n  - name: Tutorial\n    content: &#40;== include google\/foo\/tutorial.md ==&#41;\n    subpages;\n    - name: Java\n      content: &#40;== include google\/foo\/tutorial_java.md ==&#41;\n  rules:\n  - selector: google.calendar.Calendar.Get\n    description: >\n      ...\n  - selector: google.calendar.Calendar.Put\n    description: >\n      ...\n<\/code><\/pre>\nDocumentation is provided in markdown syntax. In addition to\nstandard markdown features, definition lists, tables and fenced\ncode blocks are supported. Section headers can be provided and are\ninterpreted relative to the section nesting of the context where\na documentation fragment is embedded.\n\nDocumentation from the IDL is merged with documentation defined\nvia the config at normalization time, where documentation provided\nby config rules overrides IDL provided.\n\nA number of constructs specific to the API platform are supported\nin documentation text.\n\nIn order to reference a proto element, the following\nnotation can be used:\n<pre><code>&#91;fully.qualified.proto.name]&#91;]<\/code><\/pre>\nTo override the display text used for the link, this can be used:\n<pre><code>&#91;display text]&#91;fully.qualified.proto.name]<\/code><\/pre>\nText can be excluded from doc using the following notation:\n<pre><code>&#40;-- internal comment --&#41;<\/code><\/pre>\nComments can be made conditional using a visibility label. The below\ntext will be only rendered if the `BETA` label is available:\n<pre><code>&#40;--BETA: comment for BETA users --&#41;<\/code><\/pre>\nA few directives are available in documentation. Note that\ndirectives must appear on a single line to be properly\nidentified. The `include` directive includes a markdown file from\nan external source:\n<pre><code>&#40;== include path\/to\/file ==&#41;<\/code><\/pre>\nThe `resource_for` directive marks a message to be the resource of\na collection in REST view. If it is not specified, tools attempt\nto infer the resource from the operations in a collection:\n<pre><code>&#40;== resource_for v1.shelves.books ==&#41;<\/code><\/pre>\nThe directive `suppress_warning` does not directly affect documentation\nand is documented together with service config validation.",
      "type": "object",
      "properties": {
        "summary": {
          "description": "A short summary of what the service does. Can only be provided by\nplain text.",
          "type": "string"
        },
        "pages": {
          "description": "The top level pages for the documentation set.",
          "type": "array",
          "items": {
            "$ref": "Page"
          }
        },
        "rules": {
          "description": "Documentation rules for individual elements of the service.",
          "type": "array",
          "items": {
            "$ref": "DocumentationRule"
          }
        },
        "documentationRootUrl": {
          "description": "The URL to the root of documentation.",
          "type": "string"
        },
        "overview": {
          "description": "Declares a single overview page. For example:\n<pre><code>documentation:\n  summary: ...\n  overview: &#40;== include overview.md ==&#41;\n<\/code><\/pre>\nThis is a shortcut for the following declaration (using pages style):\n<pre><code>documentation:\n  summary: ...\n  pages:\n  - name: Overview\n    content: &#40;== include overview.md ==&#41;\n<\/code><\/pre>\nNote: you cannot specify both `overview` field and `pages` field.",
          "type": "string"
        }
      }
    },
    "Page": {
      "id": "Page",
      "description": "Represents a documentation page. A page can contain subpages to represent\nnested documentation set structure.",
      "type": "object",
      "properties": {
        "name": {
          "description": "The name of the page. It will be used as an identity of the page to\ngenerate URI of the page, text of the link to this page in navigation,\netc. The full page name (start from the root page name to this page\nconcatenated with `.`) can be used as reference to the page in your\ndocumentation. For example:\n<pre><code>pages:\n- name: Tutorial\n  content: &#40;== include tutorial.md ==&#41;\n  subpages:\n  - name: Java\n    content: &#40;== include tutorial_java.md ==&#41;\n<\/code><\/pre>\nYou can reference `Java` page using Markdown reference link syntax:\n`Java`.",
          "type": "string"
        },
        "content": {
          "description": "The Markdown content of the page. You can use <code>&#40;== include {path} ==&#41;<\/code>\nto include content from a Markdown file.",
          "type": "string"
        },
        "subpages": {
          "description": "Subpages of this page. The order of subpages specified here will be\nhonored in the generated docset.",
          "type": "array",
          "items": {
            "$ref": "Page"
          }
        }
      }
    },
    "DocumentationRule": {
      "id": "DocumentationRule",
      "description": "A documentation rule provides information about individual API elements.",
      "type": "object",
      "properties": {
        "selector": {
          "description": "The selector is a comma-separated list of patterns. Each pattern is a\nqualified name of the element which may end in \"*\", indicating a wildcard.\nWildcards are only allowed at the end and for a whole component of the\nqualified name, i.e. \"foo.*\" is ok, but not \"foo.b*\" or \"foo.*.bar\". To\nspecify a default for all applicable elements, the whole pattern \"*\"\nis used.",
          "type": "string"
        },
        "description": {
          "description": "Description of the selected API(s).",
          "type": "string"
        },
        "deprecationDescription": {
          "description": "Deprecation description of the selected element(s). It can be provided if an\nelement is marked as `deprecated`.",
          "type": "string"
        }
      }
    },
    "Visibility": {
      "id": "Visibility",
      "description": "`Visibility` defines restrictions for the visibility of service\nelements.  Restrictions are specified using visibility labels\n(e.g., TRUSTED_TESTER) that are elsewhere linked to users and projects.\n\nUsers and projects can have access to more than one visibility label. The\neffective visibility for multiple labels is the union of each label's\nelements, plus any unrestricted elements.\n\nIf an element and its parents have no restrictions, visibility is\nunconditionally granted.\n\nExample:\n\n    visibility:\n      rules:\n      - selector: google.calendar.Calendar.EnhancedSearch\n        restriction: TRUSTED_TESTER\n      - selector: google.calendar.Calendar.Delegate\n        restriction: GOOGLE_INTERNAL\n\nHere, all methods are publicly visible except for the restricted methods\nEnhancedSearch and Delegate.",
      "type": "object",
      "properties": {
        "rules": {
          "description": "A list of visibility rules providing visibility configuration for\nindividual API elements.",
          "type": "array",
          "items": {
            "$ref": "VisibilityRule"
          }
        },
        "enforceRuntimeVisibility": {
          "description": "Controls whether visibility rules are enforced at runtime for requests to\nall APIs and methods.\n\nIf true, requests without method visibility will receive a\nNOT_FOUND error, and any non-visible fields will be scrubbed from\nthe response messages. In service config version 0, the default is false.\nIn later config versions, it's true.\n\nNote, the `enforce_runtime_visibility` specified in a visibility rule\noverrides this setting for the APIs or methods asscoiated with the rule.",
          "type": "boolean"
        }
      }
    },
    "VisibilityRule": {
      "id": "VisibilityRule",
      "description": "A visibility rule provides visibility configuration for an individual API\nelement.",
      "type": "object",
      "properties": {
        "selector": {
          "description": "Selects methods, messages, fields, enums, etc. to which this rule applies.\n\nRefer to selector for syntax details.",
          "type": "string"
        },
        "restriction": {
          "description": "Lists the visibility labels for this rule. Any of the listed labels grants\nvisibility to the element.\n\nIf a rule has multiple labels, removing one of the labels but not all of\nthem can break clients.\n\nExample:\n\n    visibility:\n      rules:\n      - selector: google.calendar.Calendar.EnhancedSearch\n        restriction: GOOGLE_INTERNAL, TRUSTED_TESTER\n\nRemoving GOOGLE_INTERNAL from this restriction will break clients that\nrely on this method and only had access to it through GOOGLE_INTERNAL.",
          "type": "string"
        },
        "enforceRuntimeVisibility": {
          "description": "Controls whether visibility is enforced at runtime for requests to an API\nmethod. This setting has meaning only when the selector applies to a method\nor an API.\n\nIf true, requests without method visibility will receive a\nNOT_FOUND error, and any non-visible fields will be scrubbed from\nthe response messages. The default is determined by the value of\ngoogle.api.Visibility.enforce_runtime_visibility.",
          "type": "boolean"
        }
      }
    },
    "Backend": {
      "id": "Backend",
      "description": "`Backend` defines the backend configuration for a service.",
      "type": "object",
      "properties": {
        "rules": {
          "description": "A list of backend rules providing configuration for individual API\nelements.",
          "type": "array",
          "items": {
            "$ref": "BackendRule"
          }
        }
      }
    },
    "BackendRule": {
      "id": "BackendRule",
      "description": "A backend rule provides configuration for an individual API element.",
      "type": "object",
      "properties": {
        "selector": {
          "description": "Selects the methods to which this rule applies.\n\nRefer to selector for syntax details.",
          "type": "string"
        },
        "address": {
          "description": "The address of the API backend.\n",
          "type": "string"
        },
        "deadline": {
          "description": "The number of seconds to wait for a response from a request.  The\ndefault depends on the deployment context.",
          "type": "number",
          "format": "double"
        }
      }
    },
    "Http": {
      "id": "Http",
      "description": "Defines the HTTP configuration for a service. It contains a list of\nHttpRule, each specifying the mapping of an RPC method\nto one or more HTTP REST API methods.",
      "type": "object",
      "properties": {
        "rules": {
          "description": "A list of HTTP rules for configuring the HTTP REST API methods.",
          "type": "array",
          "items": {
            "$ref": "HttpRule"
          }
        }
      }
    },
    "HttpRule": {
      "id": "HttpRule",
      "description": "`HttpRule` defines the mapping of an RPC method to one or more HTTP\nREST APIs.  The mapping determines what portions of the request\nmessage are populated from the path, query parameters, or body of\nthe HTTP request.  The mapping is typically specified as an\n`google.api.http` annotation, see \"google\/api\/annotations.proto\"\nfor details.\n\nThe mapping consists of a field specifying the path template and\nmethod kind.  The path template can refer to fields in the request\nmessage, as in the example below which describes a REST GET\noperation on a resource collection of messages:\n\n```proto\nservice Messaging {\n  rpc GetMessage(GetMessageRequest) returns (Message) {\n    option (google.api.http).get = \"\/v1\/messages\/{message_id}\/{sub.subfield}\";\n  }\n}\nmessage GetMessageRequest {\n  message SubMessage {\n    string subfield = 1;\n  }\n  string message_id = 1; \/\/ mapped to the URL\n  SubMessage sub = 2;    \/\/ `sub.subfield` is url-mapped\n}\nmessage Message {\n  string text = 1; \/\/ content of the resource\n}\n```\n\nThis definition enables an automatic, bidrectional mapping of HTTP\nJSON to RPC. Example:\n\nHTTP | RPC\n-----|-----\n`GET \/v1\/messages\/123456\/foo`  | `GetMessage(message_id: \"123456\" sub: SubMessage(subfield: \"foo\"))`\n\nIn general, not only fields but also field paths can be referenced\nfrom a path pattern. Fields mapped to the path pattern cannot be\nrepeated and must have a primitive (non-message) type.\n\nAny fields in the request message which are not bound by the path\npattern automatically become (optional) HTTP query\nparameters. Assume the following definition of the request message:\n\n```proto\nmessage GetMessageRequest {\n  message SubMessage {\n    string subfield = 1;\n  }\n  string message_id = 1; \/\/ mapped to the URL\n  int64 revision = 2;    \/\/ becomes a parameter\n  SubMessage sub = 3;    \/\/ `sub.subfield` becomes a parameter\n}\n```\n\nThis enables a HTTP JSON to RPC mapping as below:\n\nHTTP | RPC\n-----|-----\n`GET \/v1\/messages\/123456?revision=2&sub.subfield=foo` | `GetMessage(message_id: \"123456\" revision: 2 sub: SubMessage(subfield: \"foo\"))`\n\nNote that fields which are mapped to HTTP parameters must have a\nprimitive type or a repeated primitive type. Message types are not\nallowed. In the case of a repeated type, the parameter can be\nrepeated in the URL, as in `...?param=A&param=B`.\n\nFor HTTP method kinds which allow a request body, the `body` field\nspecifies the mapping. Consider a REST update method on the\nmessage resource collection:\n\n```proto\nservice Messaging {\n  rpc UpdateMessage(UpdateMessageRequest) returns (Message) {\n    option (google.api.http) = {\n      put: \"\/v1\/messages\/{message_id}\"\n      body: \"message\"\n    };\n  }\n}\nmessage UpdateMessageRequest {\n  string message_id = 1; \/\/ mapped to the URL\n  Message message = 2;   \/\/ mapped to the body\n}\n```\n\nThe following HTTP JSON to RPC mapping is enabled, where the\nrepresentation of the JSON in the request body is determined by\nprotos JSON encoding:\n\nHTTP | RPC\n-----|-----\n`PUT \/v1\/messages\/123456 { \"text\": \"Hi!\" }` | `UpdateMessage(message_id: \"123456\" message { text: \"Hi!\" })`\n\nThe special name `*` can be used in the body mapping to define that\nevery field not bound by the path template should be mapped to the\nrequest body.  This enables the following alternative definition of\nthe update method:\n\n```proto\nservice Messaging {\n  rpc UpdateMessage(Message) returns (Message) {\n    option (google.api.http) = {\n      put: \"\/v1\/messages\/{message_id}\"\n      body: \"*\"\n    };\n  }\n}\nmessage Message {\n  string message_id = 1;\n  string text = 2;\n}\n```\n\nThe following HTTP JSON to RPC mapping is enabled:\n\nHTTP | RPC\n-----|-----\n`PUT \/v1\/messages\/123456 { \"text\": \"Hi!\" }` | `UpdateMessage(message_id: \"123456\" text: \"Hi!\")`\n\nNote that when using `*` in the body mapping, it is not possible to\nhave HTTP parameters, as all fields not bound by the path end in\nthe body. This makes this option more rarely used in practice of\ndefining REST APIs. The common usage of `*` is in custom methods\nwhich don't use the URL at all for transferring data.\n\nIt is possible to define multiple HTTP methods for one RPC by using\nthe `additional_bindings` option. Example:\n\n```proto\nservice Messaging {\n  rpc GetMessage(GetMessageRequest) returns (Message) {\n    option (google.api.http) = {\n      get: \"\/v1\/messages\/{message_id}\"\n      additional_bindings {\n        get: \"\/v1\/users\/{user_id}\/messages\/{message_id}\"\n      }\n    };\n  }\n}\nmessage GetMessageRequest {\n  string message_id = 1;\n  string user_id = 2;\n}\n```\n\nThis enables the following two alternative HTTP JSON to RPC\nmappings:\n\nHTTP | RPC\n-----|-----\n`GET \/v1\/messages\/123456` | `GetMessage(message_id: \"123456\")`\n`GET \/v1\/users\/me\/messages\/123456` | `GetMessage(user_id: \"me\" message_id: \"123456\")`\n\n# Rules for HTTP mapping\n\nThe rules for mapping HTTP path, query parameters, and body fields\nto the request message are as follows:\n\n1. The `body` field specifies either `*` or a field path, or is\n   omitted. If omitted, it assumes there is no HTTP body.\n2. Leaf fields (recursive expansion of nested messages in the\n   request) can be classified into three types:\n    (a) Matched in the URL template.\n    (b) Covered by body (if body is `*`, everything except (a) fields;\n        else everything under the body field)\n    (c) All other fields.\n3. URL query parameters found in the HTTP request are mapped to (c) fields.\n4. Any body sent with an HTTP request can contain only (b) fields.\n\nThe syntax of the path template is as follows:\n\n    Template = \"\/\" Segments [ Verb ] ;\n    Segments = Segment { \"\/\" Segment } ;\n    Segment  = \"*\" | \"**\" | LITERAL | Variable ;\n    Variable = \"{\" FieldPath [ \"=\" Segments ] \"}\" ;\n    FieldPath = IDENT { \".\" IDENT } ;\n    Verb     = \":\" LITERAL ;\n\nThe syntax `*` matches a single path segment. It follows the semantics of\n[RFC 6570](https:\/\/tools.ietf.org\/html\/rfc6570) Section 3.2.2 Simple String\nExpansion.\n\nThe syntax `**` matches zero or more path segments. It follows the semantics\nof [RFC 6570](https:\/\/tools.ietf.org\/html\/rfc6570) Section 3.2.3 Reserved\nExpansion.\n\nThe syntax `LITERAL` matches literal text in the URL path.\n\nThe syntax `Variable` matches the entire path as specified by its template;\nthis nested template must not contain further variables. If a variable\nmatches a single path segment, its template may be omitted, e.g. `{var}`\nis equivalent to `{var=*}`.\n\nNOTE: the field paths in variables and in the `body` must not refer to\nrepeated fields or map fields.\n\nUse CustomHttpPattern to specify any HTTP method that is not included in the\n`pattern` field, such as HEAD, or \"*\" to leave the HTTP method unspecified for\na given URL path rule. The wild-card rule is useful for services that provide\ncontent to Web (HTML) clients.",
      "type": "object",
      "properties": {
        "selector": {
          "description": "Selects methods to which this rule applies.\n\nRefer to selector for syntax details.",
          "type": "string"
        },
        "get": {
          "description": "Used for listing and getting information about resources.",
          "type": "string"
        },
        "put": {
          "description": "Used for updating a resource.",
          "type": "string"
        },
        "post": {
          "description": "Used for creating a resource.",
          "type": "string"
        },
        "delete": {
          "description": "Used for deleting a resource.",
          "type": "string"
        },
        "patch": {
          "description": "Used for updating a resource.",
          "type": "string"
        },
        "custom": {
          "description": "Custom pattern is used for defining custom verbs.",
          "$ref": "CustomHttpPattern"
        },
        "body": {
          "description": "The name of the request field whose value is mapped to the HTTP body, or\n`*` for mapping all fields not captured by the path pattern to the HTTP\nbody. NOTE: the referred field must not be a repeated field.",
          "type": "string"
        },
        "mediaUpload": {
          "description": "Do not use this. For media support, add instead\n[][google.bytestream.RestByteStream] as an API to your\nconfiguration.",
          "$ref": "MediaUpload"
        },
        "mediaDownload": {
          "description": "Do not use this. For media support, add instead\n[][google.bytestream.RestByteStream] as an API to your\nconfiguration.",
          "$ref": "MediaDownload"
        },
        "additionalBindings": {
          "description": "Additional HTTP bindings for the selector. Nested bindings must\nnot contain an `additional_bindings` field themselves (that is,\nthe nesting may only be one level deep).",
          "type": "array",
          "items": {
            "$ref": "HttpRule"
          }
        }
      }
    },
    "CustomHttpPattern": {
      "id": "CustomHttpPattern",
      "description": "A custom pattern is used for defining custom HTTP verb.",
      "type": "object",
      "properties": {
        "kind": {
          "description": "The name of this custom HTTP verb.",
          "type": "string"
        },
        "path": {
          "description": "The path matched by this custom verb.",
          "type": "string"
        }
      }
    },
    "MediaUpload": {
      "id": "MediaUpload",
      "description": "Do not use this. For media support, add instead\n[][google.bytestream.RestByteStream] as an API to your\nconfiguration.",
      "type": "object",
      "properties": {
        "enabled": {
          "description": "Whether upload is enabled.",
          "type": "boolean"
        }
      }
    },
    "MediaDownload": {
      "id": "MediaDownload",
      "description": "Do not use this. For media support, add instead\n[][google.bytestream.RestByteStream] as an API to your\nconfiguration.",
      "type": "object",
      "properties": {
        "enabled": {
          "description": "Whether download is enabled.",
          "type": "boolean"
        }
      }
    },
    "Quota": {
      "id": "Quota",
      "description": "Quota configuration helps to achieve fairness and budgeting in service\nusage.\n\n- Fairness is achieved through the use of short-term quota limits\n  that are usually defined over a time window of several seconds or\n  minutes. When such a limit is applied, for example at the user\n  level, it ensures that no single user will monopolize the service\n  or a given customer's allocated portion of it.\n- Budgeting is achieved through the use of long-term quota limits\n  that are usually defined over a time window of one or more\n  days. These limits help client application developers predict the\n  usage and help budgeting.\n\nQuota enforcement uses a simple token-based algorithm for resource sharing.\n\nThe quota configuration structure is as follows:\n\n- `QuotaLimit` defines a single enforceable limit with a specified\n  token amount that can be consumed over a specific duration and\n  applies to a particular entity, like a project or an end user. If\n  the limit applies to a user, each user making the request will\n  get the specified number of tokens to consume. When the tokens\n  run out, the requests from that user will be blocked until the\n  duration elapses and the next duration window starts.\n\n- `QuotaGroup` groups a set of quota limits.\n\n- `QuotaRule` maps a method to a set of quota groups. This allows\n  sharing of quota groups across methods as well as one method\n  consuming tokens from more than one quota group. When a group\n  contains multiple limits, requests to a method consuming tokens\n  from that group must satisfy all the limits in that group.\n\nExample:\n\n    quota:\n      groups:\n      - name: ReadGroup\n        limits:\n        - description: Daily Limit\n          name: ProjectQpd\n          default_limit: 10000\n          duration: 1d\n          limit_by: CLIENT_PROJECT\n\n        - description: Per-second Limit\n          name: UserQps\n          default_limit: 20000\n          duration: 100s\n          limit_by: USER\n\n      - name: WriteGroup\n        limits:\n        - description: Daily Limit\n          name: ProjectQpd\n          default_limit: 1000\n          max_limit: 1000\n          duration: 1d\n          limit_by: CLIENT_PROJECT\n\n        - description: Per-second Limit\n          name: UserQps\n          default_limit: 2000\n          max_limit: 4000\n          duration: 100s\n          limit_by: USER\n\n      rules:\n      - selector: \"*\"\n        groups:\n        - group: ReadGroup\n      - selector: google.calendar.Calendar.Update\n        groups:\n        - group: WriteGroup\n          cost: 2\n      - selector: google.calendar.Calendar.Delete\n        groups:\n        - group: WriteGroup\n\nHere, the configuration defines two quota groups: ReadGroup and WriteGroup,\neach defining its own daily and per-second limits. Note that One Platform\nenforces per-second limits averaged over a duration of 100 seconds. The rules\nmap ReadGroup for all methods, except for the Update and Delete methods.\nThese two methods consume from WriteGroup, with Update method consuming at\ntwice the rate as Delete method.\n\nMultiple quota groups can be specified for a method. The quota limits in all\nof those groups will be enforced. Example:\n\n    quota:\n      groups:\n      - name: WriteGroup\n        limits:\n        - description: Daily Limit\n          name: ProjectQpd\n          default_limit: 1000\n          max_limit: 1000\n          duration: 1d\n          limit_by: CLIENT_PROJECT\n\n        - description: Per-second Limit\n          name: UserQps\n          default_limit: 2000\n          max_limit: 4000\n          duration: 100s\n          limit_by: USER\n\n      - name: StorageGroup\n        limits:\n        - description: Storage Quota\n          name: StorageQuota\n          default_limit: 1000\n          duration: 0\n          limit_by: USER\n\n      rules:\n      - selector: google.calendar.Calendar.Create\n        groups:\n        - group: StorageGroup\n        - group: WriteGroup\n      - selector: google.calendar.Calendar.Delete\n        groups:\n        - group: StorageGroup\n\nIn the above example, the Create and Delete methods manage the user's\nstorage space. In addition, Create method uses WriteGroup to manage the\nrequests. In this case, requests to Create method need to satisfy all quota\nlimits defined in both quota groups.\n\nOne can disable quota for selected method(s) identified by the selector by\nsetting disable_quota to ture. For example,\n\n      rules:\n      - selector: \"*\"\n        group:\n        - group ReadGroup\n      - selector: google.calendar.Calendar.Select\n        disable_quota: true\n",
      "type": "object",
      "properties": {
        "groups": {
          "description": "List of `QuotaGroup` definitions for the service.",
          "type": "array",
          "items": {
            "$ref": "QuotaGroup"
          }
        },
        "rules": {
          "description": "List of `QuotaRule` definitions, each one mapping a selected method to one\nor more quota groups.",
          "type": "array",
          "items": {
            "$ref": "QuotaRule"
          }
        }
      }
    },
    "QuotaGroup": {
      "id": "QuotaGroup",
      "description": "`QuotaGroup` defines a set of quota limits to enforce.",
      "type": "object",
      "properties": {
        "name": {
          "description": "Name of this quota group. Must be unique within the service.\n\nQuota group name is used as part of the id for quota limits. Once the quota\ngroup has been put into use, the name of the quota group should be\nimmutable.",
          "type": "string"
        },
        "description": {
          "description": "User-visible description of this quota group.",
          "type": "string"
        },
        "limits": {
          "description": "Quota limits to be enforced when this quota group is used. A request must\nsatisfy all the limits in a group for it to be permitted.",
          "type": "array",
          "items": {
            "$ref": "QuotaLimit"
          }
        },
        "billable": {
          "description": "Indicates if the quota limits defined in this quota group apply to\nconsumers who have active billing. Quota limits defined in billable\ngroups will be applied only to consumers who have active billing. The\namount of tokens consumed from billable quota group will also be reported\nfor billing. Quota limits defined in non-billable groups will be applied\nonly to consumers who have no active billing.",
          "type": "boolean"
        }
      }
    },
    "QuotaLimit": {
      "id": "QuotaLimit",
      "description": "`QuotaLimit` defines a specific limit that applies over a specified duration\nfor a limit type. There can be at most one limit for a duration and limit\ntype combination defined within a `QuotaGroup`.",
      "type": "object",
      "properties": {
        "name": {
          "description": "Name of the quota limit.  Must be unique within the quota group.\nThis name is used to refer to the limit when overriding the limit on\na per-project basis.  If a name is not provided, it will be generated\nfrom the limit_by and duration fields.\n\nThe maximum length of the limit name is 64 characters.\n\nThe name of a limit is used as a unique identifier for this limit.\nTherefore, once a limit has been put into use, its name should be\nimmutable. You can use the display_name field to provide a user-friendly\nname for the limit. The display name can be evolved over time without\naffecting the identity of the limit.\n",
          "type": "string"
        },
        "limitBy": {
          "description": "Limit type to use for enforcing this quota limit. Each unique value gets\nthe defined number of tokens to consume from. For a quota limit that uses\nuser type, each user making requests through the same client application\nproject will get his\/her own pool of tokens to consume, whereas for a limit\nthat uses client project type, all users making requests through the same\nclient application project share a single pool of tokens.",
          "enumDescriptions": [
            "ID of the project owned by the client application developer making the\nrequest.",
            "ID of the end user making the request using the client application."
          ],
          "type": "string",
          "enum": [
            "CLIENT_PROJECT",
            "USER"
          ]
        },
        "description": {
          "description": "Optional. User-visible, extended description for this quota limit.\nShould be used only when more context is needed to understand this limit\nthan provided by the limit's display name (see: `display_name`).",
          "type": "string"
        },
        "defaultLimit": {
          "description": "Default number of tokens that can be consumed during the specified\nduration. This is the number of tokens assigned when a client\napplication developer activates the service for his\/her project.\n\nSpecifying a value of 0 will block all requests. This can be used if you\nare provisioning quota to selected consumers and blocking others.\nSimilarly, a value of -1 will indicate an unlimited quota. No other\nnegative values are allowed.",
          "type": "string",
          "format": "int64"
        },
        "maxLimit": {
          "description": "Maximum number of tokens that can be consumed during the specified\nduration. Client application developers can override the default limit up\nto this maximum. If specified, this value cannot be set to a value less\nthan the default limit. If not specified, it is set to the default limit.\n\nTo allow clients to apply overrides with no upper bound, set this to -1,\nindicating unlimited maximum quota.",
          "type": "string",
          "format": "int64"
        },
        "freeTier": {
          "description": "Free tier value displayed in the Developers Console for this limit.\nThe free tier is the number of tokens that will be subtracted from the\nbilled amount when billing is enabled.\nThis field can only be set on a limit with duration \"1d\", in a billable\ngroup; it is invalid on any other limit. If this field is not set, it\ndefaults to 0, indicating that there is no free tier for this service.",
          "type": "string",
          "format": "int64"
        },
        "duration": {
          "description": "Duration of this limit in textual notation. Example: \"100s\", \"24h\", \"1d\".\nFor duration longer than a day, only multiple of days is supported. We\nsupport only \"100s\" and \"1d\" for now. Additional support will be added in\nthe future. \"0\" indicates indefinite duration.",
          "type": "string"
        },
        "displayName": {
          "description": "User-visible display name for this limit.\nOptional. If not set, the UI will provide a default display name based on\nthe quota configuration. This field can be used to override the default\ndisplay name generated from the configuration.",
          "type": "string"
        }
      }
    },
    "QuotaRule": {
      "id": "QuotaRule",
      "description": "`QuotaRule` maps a method to a set of `QuotaGroup`s.",
      "type": "object",
      "properties": {
        "selector": {
          "description": "Selects methods to which this rule applies.\n\nRefer to selector for syntax details.",
          "type": "string"
        },
        "groups": {
          "description": "Quota groups to be used for this method. This supports associating a cost\nwith each quota group.",
          "type": "array",
          "items": {
            "$ref": "QuotaGroupMapping"
          }
        },
        "disableQuota": {
          "description": "Indicates if quota checking should be enforced. Quota will be disabled for\nmethods without quota rules or with quota rules having this field set to\ntrue. When this field is set to true, no quota group mapping is allowed.",
          "type": "boolean"
        }
      }
    },
    "QuotaGroupMapping": {
      "id": "QuotaGroupMapping",
      "description": "A quota group mapping.",
      "type": "object",
      "properties": {
        "group": {
          "description": "The `QuotaGroup.name` of the group. Requests for the mapped methods will\nconsume tokens from each of the limits defined in this group.",
          "type": "string"
        },
        "cost": {
          "description": "Number of tokens to consume for each request. This allows different cost\nto be associated with different methods that consume from the same quota\ngroup. By default, each request will cost one token.",
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "Authentication": {
      "id": "Authentication",
      "description": "`Authentication` defines the authentication configuration for an API.\n\nExample for an API targeted for external use:\n\n    name: calendar.googleapis.com\n    authentication:\n      rules:\n      - selector: \"*\"\n        oauth:\n          canonical_scopes: https:\/\/www.googleapis.com\/auth\/calendar\n\n      - selector: google.calendar.Delegate\n        oauth:\n          canonical_scopes: https:\/\/www.googleapis.com\/auth\/calendar.read",
      "type": "object",
      "properties": {
        "rules": {
          "description": "Individual rules for authentication.",
          "type": "array",
          "items": {
            "$ref": "AuthenticationRule"
          }
        },
        "providers": {
          "description": "Defines a set of authentication providers that a service supports.",
          "type": "array",
          "items": {
            "$ref": "AuthProvider"
          }
        }
      }
    },
    "AuthenticationRule": {
      "id": "AuthenticationRule",
      "description": "Authentication rules for the service.\n\nBy default, if a method has any authentication requirements, every request\nmust include a valid credential matching one of the requirements.\nIt's an error to include more than one kind of credential in a single\nrequest.\n\nIf a method doesn't have any auth requirements, request credentials will be\nignored.\n",
      "type": "object",
      "properties": {
        "selector": {
          "description": "Selects the methods to which this rule applies.\n\nRefer to selector for syntax details.",
          "type": "string"
        },
        "oauth": {
          "description": "The requirements for OAuth credentials.",
          "$ref": "OAuthRequirements"
        },
        "allowWithoutCredential": {
          "description": "Whether to allow requests without a credential.  If quota is enabled, an\nAPI key is required for such request to pass the quota check.\n",
          "type": "boolean"
        },
        "requirements": {
          "description": "Requirements for additional authentication providers.",
          "type": "array",
          "items": {
            "$ref": "AuthRequirement"
          }
        }
      }
    },
    "OAuthRequirements": {
      "id": "OAuthRequirements",
      "description": "OAuth scopes are a way to define data and permissions on data. For example,\nthere are scopes defined for \"Read-only access to Google Calendar\" and\n\"Access to Cloud Platform\". Users can consent to a scope for an application,\ngiving it permission to access that data on their behalf.\n\nOAuth scope specifications should be fairly coarse grained; a user will need\nto see and understand the text description of what your scope means.\n\nIn most cases: use one or at most two OAuth scopes for an entire family of\nproducts. If your product has multiple APIs, you should probably be sharing\nthe OAuth scope across all of those APIs.\n\nWhen you need finer grained OAuth consent screens: talk with your product\nmanagement about how developers will use them in practice.\n\nPlease note that even though each of the canonical scopes is enough for a\nrequest to be accepted and passed to the backend, a request can still fail\ndue to the backend requiring additional scopes or permissions.\n",
      "type": "object",
      "properties": {
        "canonicalScopes": {
          "description": "The list of publicly documented OAuth scopes that are allowed access. An\nOAuth token containing any of these scopes will be accepted.\n\nExample:\n\n     canonical_scopes: https:\/\/www.googleapis.com\/auth\/calendar,\n                       https:\/\/www.googleapis.com\/auth\/calendar.read",
          "type": "string"
        }
      }
    },
    "AuthRequirement": {
      "id": "AuthRequirement",
      "description": "User-defined authentication requirements, including support for\n[JSON Web Token (JWT)](https:\/\/tools.ietf.org\/html\/draft-ietf-oauth-json-web-token-32).",
      "type": "object",
      "properties": {
        "providerId": {
          "description": "id from authentication provider.\n\nExample:\n\n    provider_id: bookstore_auth",
          "type": "string"
        },
        "audiences": {
          "description": "The list of JWT\n[audiences](https:\/\/tools.ietf.org\/html\/draft-ietf-oauth-json-web-token-32#section-4.1.3).\nthat are allowed to access. A JWT containing any of these audiences will\nbe accepted. When this setting is absent, only JWTs with audience\n\"https:\/\/Service_name\/API_name\"\nwill be accepted. For example, if no audiences are in the setting,\nLibraryService API will only accept JWTs with the following audience\n\"https:\/\/library-example.googleapis.com\/google.example.library.v1.LibraryService\".\n\nExample:\n\n    audiences: bookstore_android.apps.googleusercontent.com,\n               bookstore_web.apps.googleusercontent.com",
          "type": "string"
        }
      }
    },
    "AuthProvider": {
      "id": "AuthProvider",
      "description": "Configuration for an anthentication provider, including support for\n[JSON Web Token (JWT)](https:\/\/tools.ietf.org\/html\/draft-ietf-oauth-json-web-token-32).",
      "type": "object",
      "properties": {
        "id": {
          "description": "The unique identifier of the auth provider. It will be referred to by\n`AuthRequirement.provider_id`.\n\nExample: \"bookstore_auth\".",
          "type": "string"
        },
        "issuer": {
          "description": "Identifies the principal that issued the JWT. See\nhttps:\/\/tools.ietf.org\/html\/draft-ietf-oauth-json-web-token-32#section-4.1.1\nUsually a URL or an email address.\n\nExample: https:\/\/securetoken.google.com\nExample: 1234567-compute@developer.gserviceaccount.com",
          "type": "string"
        },
        "jwksUri": {
          "description": "URL of the provider's public key set to validate signature of the JWT. See\n[OpenID Discovery](https:\/\/openid.net\/specs\/openid-connect-discovery-1_0.html#ProviderMetadata).\nOptional if the key set document:\n - can be retrieved from\n   [OpenID Discovery](https:\/\/openid.net\/specs\/openid-connect-discovery-1_0.html\n   of the issuer.\n - can be inferred from the email domain of the issuer (e.g. a Google service account).\n\nExample: https:\/\/www.googleapis.com\/oauth2\/v1\/certs",
          "type": "string"
        }
      }
    },
    "Context": {
      "id": "Context",
      "description": "`Context` defines which contexts an API requests.\n\nExample:\n\n    context:\n      rules:\n      - selector: \"*\"\n        requested:\n        - google.rpc.context.ProjectContext\n        - google.rpc.context.OriginContext\n\nThe above specifies that all methods in the API request\n`google.rpc.context.ProjectContext` and\n`google.rpc.context.OriginContext`.\n\nAvailable context types are defined in package\n`google.rpc.context`.",
      "type": "object",
      "properties": {
        "rules": {
          "description": "List of rules for context, applicable to methods.",
          "type": "array",
          "items": {
            "$ref": "ContextRule"
          }
        }
      }
    },
    "ContextRule": {
      "id": "ContextRule",
      "description": "A context rule provides information about the context for an individual API\nelement.",
      "type": "object",
      "properties": {
        "selector": {
          "description": "Selects the methods to which this rule applies.\n\nRefer to selector for syntax details.",
          "type": "string"
        },
        "requested": {
          "description": "A list of full type names of requested contexts.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "provided": {
          "description": "A list of full type names of provided contexts.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "Usage": {
      "id": "Usage",
      "description": "Configuration controlling usage of a service.",
      "type": "object",
      "properties": {
        "serviceAccess": {
          "description": "Controls which users can see or activate the service.",
          "enumDescriptions": [
            "The service can only be seen\/used by users identified in the service's\naccess control policy.\n\nIf the service has not been whitelisted by your domain administrator\nfor out-of-org publishing, then this mode will be treated like\nORG_RESTRICTED.",
            "The service can be seen\/used by anyone.\n\nIf the service has not been whitelisted by your domain administrator\nfor out-of-org publishing, then this mode will be treated like\nORG_PUBLIC.\n\nThe discovery document for the service will also be public and allow\nunregistered access.",
            "The service can be seen\/used by users identified in the service's\naccess control policy and they are within the organization that owns the\nservice.\n\nAccess is further constrained to the group\ncontrolled by the administrator of the project\/org that owns the\nservice.",
            "The service can be seen\/used by the group of users controlled by the\nadministrator of the project\/org that owns the service."
          ],
          "type": "string",
          "enum": [
            "RESTRICTED",
            "PUBLIC",
            "ORG_RESTRICTED",
            "ORG_PUBLIC"
          ]
        },
        "requirements": {
          "description": "Requirements that must be satisfied before a consumer project can use the\nservice. Each requirement is of the form <service.name>\/<requirement-id>;\nfor example 'serviceusage.googleapis.com\/billing-enabled'.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "dependsOnServices": {
          "description": "Services that must be activated in order for this service to be used.\nThe set of services activated as a result of these relations are all\nactivated in parallel with no guaranteed order of activation.\nEach string is a service name, e.g. `calendar.googleapis.com`.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "activationHooks": {
          "description": "Services that must be contacted before a consumer can begin using the\nservice. Each service will be contacted in sequence, and, if any activation\ncall fails, the entire activation will fail. Each hook is of the form\n<service.name>\/<hook-id>, where <hook-id> is optional; for example:\n'robotservice.googleapis.com\/default'.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "deactivationHooks": {
          "description": "Services that must be contacted before a consumer can deactivate a\nservice. Each service will be contacted in sequence, and, if any\ndeactivation call fails, the entire deactivation will fail. Each hook is\nof the form <service.name>\/<hook-id>, where <hook-id> is optional; for\nexample:\n'compute.googleapis.com\/'.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "rules": {
          "description": "Individual rules for configuring usage on selected methods.",
          "type": "array",
          "items": {
            "$ref": "UsageRule"
          }
        }
      }
    },
    "UsageRule": {
      "id": "UsageRule",
      "description": "Usage configuration rules for the service.\n\nNOTE: Under development.\n\n\nUse this rule to configure unregistered calls for the service. Unregistered\ncalls are calls that do not contain consumer project identity.\n(Example: calls that do not contain an API key).\nBy default, API methods do not allow unregistered calls, and each method call\nmust be identified by a consumer project identity. Use this rule to\nallow\/disallow unregistered calls.\n\nExample of an API that wants to allow unregistered calls for entire service.\n\n    usage:\n      rules:\n      - selector: \"*\"\n        allow_unregistered_calls: true\n\nExample of a method that wants to allow unregistered calls.\n\n    usage:\n      rules:\n      - selector: \"google.example.library.v1.LibraryService.CreateBook\"\n        allow_unregistered_calls: true",
      "type": "object",
      "properties": {
        "selector": {
          "description": "Selects the methods to which this rule applies. Use '*' to indicate all\nmethods in all APIs.\n\nRefer to selector for syntax details.",
          "type": "string"
        },
        "allowUnregisteredCalls": {
          "description": "True, if the method allows unregistered calls; false otherwise.",
          "type": "boolean"
        }
      }
    },
    "CustomError": {
      "id": "CustomError",
      "description": "Customize service error responses.  For example, list any service\nspecific protobuf types that can appear in error detail lists of\nerror responses.\n\nExample:\n\n    custom_error:\n      types:\n      - google.foo.v1.CustomError\n      - google.foo.v1.AnotherError\n",
      "type": "object",
      "properties": {
        "rules": {
          "description": "The list of custom error rules to select to which messages this should\napply.",
          "type": "array",
          "items": {
            "$ref": "CustomErrorRule"
          }
        },
        "types": {
          "description": "The list of custom error detail types, e.g. 'google.foo.v1.CustomError'.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "CustomErrorRule": {
      "id": "CustomErrorRule",
      "description": "A custom error rule.",
      "type": "object",
      "properties": {
        "selector": {
          "description": "Selects messages to which this rule applies.\n\nRefer to selector for syntax details.",
          "type": "string"
        },
        "isErrorType": {
          "description": "Mark this message as possible payload in error response.  Otherwise,\nobjects of this type will be filtered when they appear in error payload.",
          "type": "boolean"
        }
      }
    },
    "ProjectProperties": {
      "id": "ProjectProperties",
      "description": "A descriptor for defining project properties for a service. One service may\nhave many consumer projects, and the service may want to behave differently\ndepending on some properties on the project. For example, a project may be\nassociated with a school, or a business, or a government agency, a business\ntype property on the project may affect how a service responds to the client.\nThis descriptor defines which properties are allowed to be set on a project.\n\nExample:\n\n   project_properties:\n     properties:\n     - name: NO_WATERMARK\n       type: BOOL\n       description: Allows usage of the API without watermarks.\n     - name: EXTENDED_TILE_CACHE_PERIOD\n       type: INT64",
      "type": "object",
      "properties": {
        "properties": {
          "description": "List of per consumer project-specific properties.",
          "type": "array",
          "items": {
            "$ref": "Property"
          }
        }
      }
    },
    "Property": {
      "id": "Property",
      "description": "Defines project properties.\n\nAPI services can define properties that can be assigned to consumer projects\nso that backends can perform response customization without having to make\nadditional calls or maintain additional storage. For example, Maps API\ndefines properties that controls map tile cache period, or whether to embed a\nwatermark in a result.\n\nThese values can be set via API producer console. Only API providers can\ndefine and set these properties.",
      "type": "object",
      "properties": {
        "name": {
          "description": "The name of the property (a.k.a key).",
          "type": "string"
        },
        "type": {
          "description": "The type of this property.",
          "enumDescriptions": [
            "The type is unspecified, and will result in an error.",
            "The type is `int64`.",
            "The type is `bool`.",
            "The type is `string`.",
            "The type is 'double'."
          ],
          "type": "string",
          "enum": [
            "UNSPECIFIED",
            "INT64",
            "BOOL",
            "STRING",
            "DOUBLE"
          ]
        },
        "description": {
          "description": "The description of the property",
          "type": "string"
        }
      }
    },
    "Control": {
      "id": "Control",
      "description": "Selects and configures the service controller used by the service.  The\nservice controller handles features like abuse, quota, billing, logging,\nmonitoring, etc.\n",
      "type": "object",
      "properties": {
        "environment": {
          "description": "The service control environment to use. If empty, no control plane\nfeature (like quota and billing) will be enabled.",
          "type": "string"
        }
      }
    },
    "LogDescriptor": {
      "id": "LogDescriptor",
      "description": "A description of a log type. Example in YAML format:\n\n    - name: library.googleapis.com\/activity_history\n      description: The history of borrowing and returning library items.\n      display_name: Activity\n      labels:\n      - key: \/customer_id\n        description: Identifier of a library customer",
      "type": "object",
      "properties": {
        "name": {
          "description": "The name of the log. It must be less than 512 characters long and can\ninclude the following characters: upper- and lower-case alphanumeric\ncharacters [A-Za-z0-9], and punctuation characters including\nslash, underscore, hyphen, period [\/_-.].",
          "type": "string"
        },
        "labels": {
          "description": "The set of labels that are available to describe a specific log entry.\nRuntime requests that contain labels not specified here are\nconsidered invalid.",
          "type": "array",
          "items": {
            "$ref": "LabelDescriptor"
          }
        },
        "description": {
          "description": "A human-readable description of this log. This information appears in\nthe documentation and can contain details.",
          "type": "string"
        },
        "displayName": {
          "description": "The human-readable name for this log. This information appears on\nthe user interface and should be concise.",
          "type": "string"
        }
      }
    },
    "LabelDescriptor": {
      "id": "LabelDescriptor",
      "description": "A description of a label.",
      "type": "object",
      "properties": {
        "key": {
          "description": "The label key.",
          "type": "string"
        },
        "valueType": {
          "description": "The type of data that can be assigned to the label.",
          "enumDescriptions": [
            "A variable-length string. This is the default.",
            "Boolean; true or false.",
            "A 64-bit signed integer."
          ],
          "type": "string",
          "enum": [
            "STRING",
            "BOOL",
            "INT64"
          ]
        },
        "description": {
          "description": "A human-readable description for the label.",
          "type": "string"
        }
      }
    },
    "MetricDescriptor": {
      "id": "MetricDescriptor",
      "description": "Defines a metric type and its schema.",
      "type": "object",
      "properties": {
        "name": {
          "description": "Resource name. The format of the name may vary between different\nimplementations. For examples:\n\n    projects\/{project_id}\/metricDescriptors\/{type=**}\n    metricDescriptors\/{type=**}",
          "type": "string"
        },
        "type": {
          "description": "The metric type including a DNS name prefix, for example\n`\"compute.googleapis.com\/instance\/cpu\/utilization\"`. Metric types\nshould use a natural hierarchical grouping such as the following:\n\n    compute.googleapis.com\/instance\/cpu\/utilization\n    compute.googleapis.com\/instance\/disk\/read_ops_count\n    compute.googleapis.com\/instance\/network\/received_bytes_count\n\nNote that if the metric type changes, the monitoring data will be\ndiscontinued, and anything depends on it will break, such as monitoring\ndashboards, alerting rules and quota limits. Therefore, once a metric has\nbeen published, its type should be immutable.",
          "type": "string"
        },
        "labels": {
          "description": "The set of labels that can be used to describe a specific instance of this\nmetric type. For example, the\n`compute.googleapis.com\/instance\/network\/received_bytes_count` metric type\nhas a label, `loadbalanced`, that specifies whether the traffic was\nreceived through a load balanced IP address.",
          "type": "array",
          "items": {
            "$ref": "LabelDescriptor"
          }
        },
        "metricKind": {
          "description": "Whether the metric records instantaneous values, changes to a value, etc.",
          "enumDescriptions": [
            "Do not use this default value.",
            "Instantaneous measurements of a varying quantity.",
            "Changes over non-overlapping time intervals.",
            "Cumulative value over time intervals that can overlap.\nThe overlapping intervals must have the same start time."
          ],
          "type": "string",
          "enum": [
            "METRIC_KIND_UNSPECIFIED",
            "GAUGE",
            "DELTA",
            "CUMULATIVE"
          ]
        },
        "valueType": {
          "description": "Whether the measurement is an integer, a floating-point number, etc.",
          "enumDescriptions": [
            "Do not use this default value.",
            "The value is a boolean.\nThis value type can be used only if the metric kind is `GAUGE`.",
            "The value is a signed 64-bit integer.",
            "The value is a double precision floating point number.",
            "The value is a text string.\nThis value type can be used only if the metric kind is `GAUGE`.",
            "The value is a `Distribution`.",
            "The value is money."
          ],
          "type": "string",
          "enum": [
            "VALUE_TYPE_UNSPECIFIED",
            "BOOL",
            "INT64",
            "DOUBLE",
            "STRING",
            "DISTRIBUTION",
            "MONEY"
          ]
        },
        "unit": {
          "description": "The unit in which the metric value is reported. It is only applicable\nif the `value_type` is `INT64`, `DOUBLE`, or `DISTRIBUTION`. The\nsupported units are a subset of [The Unified Code for Units of\nMeasure](http:\/\/unitsofmeasure.org\/ucum.html) standard:\n\n**Basic units (UNIT)**\n\n* `bit`   bit\n* `By`    byte\n* `s`     second\n* `min`   minute\n* `h`     hour\n* `d`     day\n\n**Prefixes (PREFIX)**\n\n* `k`     kilo    (10**3)\n* `M`     mega    (10**6)\n* `G`     giga    (10**9)\n* `T`     tera    (10**12)\n* `P`     peta    (10**15)\n* `E`     exa     (10**18)\n* `Z`     zetta   (10**21)\n* `Y`     yotta   (10**24)\n* `m`     milli   (10**-3)\n* `u`     micro   (10**-6)\n* `n`     nano    (10**-9)\n* `p`     pico    (10**-12)\n* `f`     femto   (10**-15)\n* `a`     atto    (10**-18)\n* `z`     zepto   (10**-21)\n* `y`     yocto   (10**-24)\n* `Ki`    kibi    (2**10)\n* `Mi`    mebi    (2**20)\n* `Gi`    gibi    (2**30)\n* `Ti`    tebi    (2**40)\n\n**Grammar**\n\nThe grammar includes the dimensionless unit `1`, such as `1\/s`.\n\nThe grammar also includes these connectors:\n\n* `\/`    division (as an infix operator, e.g. `1\/s`).\n* `.`    multiplication (as an infix operator, e.g. `GBy.d`)\n\nThe grammar for a unit is as follows:\n\n    Expression = Component { \".\" Component } { \"\/\" Component } ;\n\n    Component = [ PREFIX ] UNIT [ Annotation ]\n              | Annotation\n              | \"1\"\n              ;\n\n    Annotation = \"{\" NAME \"}\" ;\n\nNotes:\n\n* `Annotation` is just a comment if it follows a `UNIT` and is\n   equivalent to `1` if it is used alone. For examples,\n   `{requests}\/s == 1\/s`, `By{transmitted}\/s == By\/s`.\n* `NAME` is a sequence of non-blank printable ASCII characters not\n   containing '{' or '}'.",
          "type": "string"
        },
        "description": {
          "description": "A detailed description of the metric, which can be used in documentation.",
          "type": "string"
        },
        "displayName": {
          "description": "A concise name for the metric, which can be displayed in user interfaces.\nUse sentence case without an ending period, for example \"Request count\".",
          "type": "string"
        }
      }
    },
    "MonitoredResourceDescriptor": {
      "id": "MonitoredResourceDescriptor",
      "description": "An object that describes the schema of a MonitoredResource object using a\ntype name and a set of labels.  For example, the monitored resource\ndescriptor for Google Compute Engine VM instances has a type of\n`\"gce_instance\"` and specifies the use of the labels `\"instance_id\"` and\n`\"zone\"` to identify particular VM instances.\n\nDifferent APIs can support different monitored resource types. APIs generally\nprovide a `list` method that returns the monitored resource descriptors used\nby the API.",
      "type": "object",
      "properties": {
        "name": {
          "description": "Optional. The resource name of the monitored resource descriptor:\n`\"projects\/{project_id}\/monitoredResourceDescriptors\/{type}\"` where\n{type} is the value of the `type` field in this object and\n{project_id} is a project ID that provides API-specific context for\naccessing the type.  APIs that do not use project information can use the\nresource name format `\"monitoredResourceDescriptors\/{type}\"`.",
          "type": "string"
        },
        "type": {
          "description": "Required. The monitored resource type. For example, the type\n`\"cloudsql_database\"` represents databases in Google Cloud SQL.\nThe maximum length of this value is 256 characters.",
          "type": "string"
        },
        "displayName": {
          "description": "Optional. A concise name for the monitored resource type that might be\ndisplayed in user interfaces. For example, `\"Google Cloud SQL Database\"`.",
          "type": "string"
        },
        "description": {
          "description": "Optional. A detailed description of the monitored resource type that might\nbe used in documentation.",
          "type": "string"
        },
        "labels": {
          "description": "Required. A set of labels used to describe instances of this monitored\nresource type. For example, an individual Google Cloud SQL database is\nidentified by values for the labels `\"database_id\"` and `\"zone\"`.",
          "type": "array",
          "items": {
            "$ref": "LabelDescriptor"
          }
        }
      }
    },
    "Billing": {
      "id": "Billing",
      "description": "Billing related configuration of the service.\n\nThe following example shows how to configure metrics for billing:\n\n    metrics:\n    - name: library.googleapis.com\/read_calls\n      metric_kind: DELTA\n      value_type: INT64\n    - name: library.googleapis.com\/write_calls\n      metric_kind: DELTA\n      value_type: INT64\n    billing:\n      metrics:\n      - library.googleapis.com\/read_calls\n      - library.googleapis.com\/write_calls\n\nThe next example shows how to enable billing status check and customize the\ncheck behavior. It makes sure billing status check is included in the `Check`\nmethod of [Service Control API](https:\/\/cloud.google.com\/service-control\/).\nIn the example, \"google.storage.Get\" method can be served when the billing\nstatus is either `current` or `delinquent`, while \"google.storage.Write\"\nmethod can only be served when the billing status is `current`:\n\n    billing:\n      rules:\n      - selector: google.storage.Get\n        allowed_statuses:\n        - current\n        - delinquent\n      - selector: google.storage.Write\n        allowed_statuses: current\n\nMostly services should only allow `current` status when serving requests.\nIn addition, services can choose to allow both `current` and `delinquent`\nstatuses when serving read-only requests to resources. If there's no\nmatching selector for operation, no billing status check will be performed.\n",
      "type": "object",
      "properties": {
        "metrics": {
          "description": "Names of the metrics to report to billing. Each name must\nbe defined in Service.metrics section.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "rules": {
          "description": "A list of billing status rules for configuring billing status check.",
          "type": "array",
          "items": {
            "$ref": "BillingStatusRule"
          }
        },
        "areaUnderCurveParams": {
          "description": "Per resource grouping for delta billing based resource configs.",
          "type": "array",
          "items": {
            "$ref": "AreaUnderCurveParams"
          }
        }
      }
    },
    "BillingStatusRule": {
      "id": "BillingStatusRule",
      "description": "Defines the billing status requirements for operations.\n\nWhen used with\n[Service Control API](https:\/\/cloud.google.com\/service-control\/), the\nfollowing statuses are supported:\n\n- **current**: the associated billing account is up to date and capable of\n               paying for resource usages.\n- **delinquent**: the associated billing account has a correctable problem,\n                  such as late payment.\n\nMostly services should only allow `current` status when serving requests.\nIn addition, services can choose to allow both `current` and `delinquent`\nstatuses when serving read-only requests to resources. If the list of\nallowed_statuses is empty, it means no billing requirement.\n",
      "type": "object",
      "properties": {
        "selector": {
          "description": "Selects the operation names to which this rule applies.\nRefer to selector for syntax details.",
          "type": "string"
        },
        "allowedStatuses": {
          "description": "Allowed billing statuses. The billing status check passes if the actual\nbilling status matches any of the provided values here.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "AreaUnderCurveParams": {
      "id": "AreaUnderCurveParams",
      "description": "AreaUnderCurveParams groups the metrics relevant to generating\nduration based metric from base (snapshot) metric and delta\n(change) metric.  The generated metric has two dimensions:\n   resource usage metric and the duration the metric applies.\n\nEssentially the generated metric is the Area Under Curve(AUC) of\nthe \"duration - resource\" usage curve. This AUC metric is readily\nappliable to billing since \"billable resource usage\" depends on\nresource usage and duration of the resource used.\n\nA service config may contain multiple resources and corresponding\nmetrics. AreaUnderCurveParams groups the relevant ones: which\nsnapshot_metric and change_metric are used to produce which\ngenerated_metric.\n",
      "type": "object",
      "properties": {
        "snapshotMetric": {
          "description": "Total usage of a resource at a particular timestamp. This should be\na GAUGE metric.",
          "type": "string"
        },
        "changeMetric": {
          "description": "Change of resource usage at a particular timestamp. This should a\nDELTA metric.",
          "type": "string"
        },
        "generatedMetric": {
          "description": "Metric generated from snapshot_metric and change_metric. This\nis also a DELTA metric.",
          "type": "string"
        }
      }
    },
    "Logging": {
      "id": "Logging",
      "description": "Logging configuration of the service.\n\nThe following example shows how to configure logs to be sent to the\nproducer and consumer projects. In the example,\nthe `library.googleapis.com\/activity_history` log is\nsent to both the producer and consumer projects, whereas\nthe `library.googleapis.com\/purchase_history` log is only sent to the\nproducer project:\n\n    monitored_resources:\n    - type: library.googleapis.com\/branch\n      labels:\n      - key: \/city\n        description: The city where the library branch is located in.\n      - key: \/name\n        description: The name of the branch.\n    logs:\n    - name: library.googleapis.com\/activity_history\n      labels:\n      - key: \/customer_id\n    - name: library.googleapis.com\/purchase_history\n    logging:\n      producer_destinations:\n      - monitored_resource: library.googleapis.com\/branch\n        logs:\n        - library.googleapis.com\/activity_history\n        - library.googleapis.com\/purchase_history\n      consumer_destinations:\n      - monitored_resource: library.googleapis.com\/branch\n        logs:\n        - library.googleapis.com\/activity_history\n",
      "type": "object",
      "properties": {
        "producerDestinations": {
          "description": "Logging configurations for sending logs to the producer project.\nThere can be multiple producer destinations, each one must have a\ndifferent monitored resource type. A log can be used in at most\none producer destination.",
          "type": "array",
          "items": {
            "$ref": "LoggingDestination"
          }
        },
        "consumerDestinations": {
          "description": "Logging configurations for sending logs to the consumer project.\nThere can be multiple consumer destinations, each one must have a\ndifferent monitored resource type. A log can be used in at most\none consumer destination.",
          "type": "array",
          "items": {
            "$ref": "LoggingDestination"
          }
        }
      }
    },
    "LoggingDestination": {
      "id": "LoggingDestination",
      "description": "Configuration of a specific logging destination (the producer project\nor the consumer project).",
      "type": "object",
      "properties": {
        "monitoredResource": {
          "description": "The monitored resource type. The type must be defined in\nService.monitored_resources section.",
          "type": "string"
        },
        "logs": {
          "description": "Names of the logs to be sent to this destination. Each name must\nbe defined in the Service.logs section.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "Monitoring": {
      "id": "Monitoring",
      "description": "Monitoring configuration of the service.\n\nThe example below shows how to configure monitored resources and metrics\nfor monitoring. In the example, a monitored resource and two metrics are\ndefined. The `library.googleapis.com\/book\/returned_count` metric is sent\nto both producer and consumer projects, whereas the\n`library.googleapis.com\/book\/overdue_count` metric is only sent to the\nconsumer project.\n\n    monitored_resources:\n    - type: library.googleapis.com\/branch\n      labels:\n      - key: \/city\n        description: The city where the library branch is located in.\n      - key: \/name\n        description: The name of the branch.\n    metrics:\n    - name: library.googleapis.com\/book\/returned_count\n      metric_kind: DELTA\n      value_type: INT64\n      labels:\n      - key: \/customer_id\n    - name: library.googleapis.com\/book\/overdue_count\n      metric_kind: GAUGE\n      value_type: INT64\n      labels:\n      - key: \/customer_id\n    monitoring:\n      producer_destinations:\n      - monitored_resource: library.googleapis.com\/branch\n        metrics:\n        - library.googleapis.com\/book\/returned_count\n      consumer_destinations:\n      - monitored_resource: library.googleapis.com\/branch\n        metrics:\n        - library.googleapis.com\/book\/returned_count\n        - library.googleapis.com\/book\/overdue_count\n",
      "type": "object",
      "properties": {
        "producerDestinations": {
          "description": "Monitoring configurations for sending metrics to the producer project.\nThere can be multiple producer destinations, each one must have a\ndifferent monitored resource type. A metric can be used in at most\none producer destination.",
          "type": "array",
          "items": {
            "$ref": "MonitoringDestination"
          }
        },
        "consumerDestinations": {
          "description": "Monitoring configurations for sending metrics to the consumer project.\nThere can be multiple consumer destinations, each one must have a\ndifferent monitored resource type. A metric can be used in at most\none consumer destination.",
          "type": "array",
          "items": {
            "$ref": "MonitoringDestination"
          }
        }
      }
    },
    "MonitoringDestination": {
      "id": "MonitoringDestination",
      "description": "Configuration of a specific monitoring destination (the producer project\nor the consumer project).",
      "type": "object",
      "properties": {
        "monitoredResource": {
          "description": "The monitored resource type. The type must be defined in\nService.monitored_resources section.",
          "type": "string"
        },
        "metrics": {
          "description": "Names of the metrics to report to this monitoring destination.\nEach name must be defined in Service.metrics section.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "SystemParameters": {
      "id": "SystemParameters",
      "description": "### System parameter configuration\n\nA system parameter is a special kind of parameter defined by the API\nsystem, not by an individual API. It is typically mapped to an HTTP header\nand\/or a URL query parameter. This configuration specifies which methods\nchange the names of the system parameters.",
      "type": "object",
      "properties": {
        "rules": {
          "description": "Define system parameters.\n\nThe parameters defined here will override the default parameters\nimplemented by the system. If this field is missing from the service\nconfig, default system parameters will be used. Default system parameters\nand names is implementation-dependent.\n\nExample: define api key and alt name for all methods\n\nsystem_parameters\n  rules:\n    - selector: \"*\"\n      parameters:\n        - name: api_key\n          url_query_parameter: api_key\n        - name: alt\n          http_header: Response-Content-Type\n\nExample: define 2 api key names for a specific method.\n\nsystem_parameters\n  rules:\n    - selector: \"\/ListShelves\"\n      parameters:\n        - name: api_key\n          http_header: Api-Key1\n        - name: api_key\n          http_header: Api-Key2",
          "type": "array",
          "items": {
            "$ref": "SystemParameterRule"
          }
        }
      }
    },
    "SystemParameterRule": {
      "id": "SystemParameterRule",
      "description": "Define a system parameter rule mapping system parameter definitions to\nmethods.",
      "type": "object",
      "properties": {
        "selector": {
          "description": "Selects the methods to which this rule applies. Use '*' to indicate all\nmethods in all APIs.\n\nRefer to selector for syntax details.",
          "type": "string"
        },
        "parameters": {
          "description": "Define parameters. Multiple names may be defined for a parameter.\nFor a given method call, only one of them should be used. If multiple\nnames are used the behavior is implementation-dependent.\nIf none of the specified names are present the behavior is\nparameter-dependent.",
          "type": "array",
          "items": {
            "$ref": "SystemParameter"
          }
        }
      }
    },
    "SystemParameter": {
      "id": "SystemParameter",
      "description": "Define a parameter's name and location. The parameter may be passed as either\nan HTTP header or a URL query parameter, and if both are passed the behavior\nis implementation-dependent.",
      "type": "object",
      "properties": {
        "name": {
          "description": "Define the name of the parameter, such as \"api_key\", \"alt\", \"callback\",\nand etc. It is case sensitive.",
          "type": "string"
        },
        "httpHeader": {
          "description": "Define the HTTP header name to use for the parameter. It is case\ninsensitive.",
          "type": "string"
        },
        "urlQueryParameter": {
          "description": "Define the URL query parameter name to use for the parameter. It is case\nsensitive.",
          "type": "string"
        }
      }
    },
    "ConfigSource": {
      "id": "ConfigSource",
      "description": "Represents a user-specified configuration for a service (as opposed to the\nthe generated service config form provided by `google.api.Service`). This is\nmeant to encode service config as manipulated directly by customers,\nrather than the config form resulting from toolchain generation and\nnormalization.",
      "type": "object",
      "properties": {
        "id": {
          "description": "A unique ID for a specific instance of this message, typically assigned\nby the client for tracking purpose. If empty, the server may choose to\ngenerate one instead.",
          "type": "string"
        },
        "options": {
          "description": "Options to cover use of source config within ServiceManager and tools",
          "$ref": "ConfigOptions"
        },
        "files": {
          "description": "Set of source configuration files that are used to generate a service\nconfig (`google.api.Service`).",
          "type": "array",
          "items": {
            "$ref": "ConfigFile"
          }
        },
        "openApiSpec": {
          "description": "OpenAPI specification",
          "$ref": "OpenApiSpec"
        },
        "protoSpec": {
          "description": "Protocol buffer API specification",
          "$ref": "ProtoSpec"
        }
      }
    },
    "ConfigOptions": {
      "id": "ConfigOptions",
      "description": "A set of options to cover use of source config within `ServiceManager`\nand related tools.",
      "type": "object",
      "properties": {
      }
    },
    "ConfigFile": {
      "id": "ConfigFile",
      "description": "Generic specification of a source configuration file",
      "type": "object",
      "properties": {
        "filePath": {
          "description": "The file name of the configuration file (full or relative path).",
          "type": "string"
        },
        "contents": {
          "description": "DEPRECATED. The contents of the configuration file. Use file_contents\nmoving forward.",
          "type": "string"
        },
        "fileContents": {
          "description": "The bytes that constitute the file.",
          "type": "string",
          "format": "byte"
        },
        "fileType": {
          "description": "The kind of configuration file represented. This is used to determine\nthe method for generating `google.api.Service` using this file.",
          "enumDescriptions": [
            "Unknown file type.",
            "YAML-specification of service.",
            "OpenAPI specification, serialized in JSON.",
            "OpenAPI specification, serialized in YAML.",
            "FileDescriptorSet, generated by protoc.\n\nTo generate, use protoc with imports and source info included.\nFor an example test.proto file, the following command would put the value\nin a new file named out.pb.\n\n$protoc --include_imports --include_source_info test.proto -o out.pb"
          ],
          "type": "string",
          "enum": [
            "FILE_TYPE_UNSPECIFIED",
            "SERVICE_CONFIG_YAML",
            "OPEN_API_JSON",
            "OPEN_API_YAML",
            "FILE_DESCRIPTOR_SET_PROTO"
          ]
        }
      }
    },
    "OpenApiSpec": {
      "id": "OpenApiSpec",
      "description": "A collection of OpenAPI specification files.",
      "type": "object",
      "properties": {
        "openApiFiles": {
          "description": "Individual files.",
          "type": "array",
          "items": {
            "$ref": "ConfigFile"
          }
        }
      }
    },
    "ProtoSpec": {
      "id": "ProtoSpec",
      "description": "A collection of protocol buffer service specification files.",
      "type": "object",
      "properties": {
        "protoDescriptor": {
          "description": "A complete descriptor of a protocol buffer specification",
          "$ref": "ProtoDescriptor"
        }
      }
    },
    "ProtoDescriptor": {
      "id": "ProtoDescriptor",
      "description": "Contains a serialized protoc-generated protocol buffer message descriptor set\nalong with a URL that describes the type of the descriptor message.",
      "type": "object",
      "properties": {
        "typeUrl": {
          "description": "A URL\/resource name whose content describes the type of the\nserialized protocol buffer message.\n\nOnly 'type.googleapis.com\/google.protobuf.FileDescriptorSet' is supported.\nIf the type_url is not specificed,\n'type.googleapis.com\/google.protobuf.FileDescriptorSet' will be assumed.\n",
          "type": "string"
        },
        "value": {
          "description": "Must be a valid serialized protocol buffer descriptor set.\n\nTo generate, use protoc with imports and source info included.\nFor an example test.proto file, the following command would put the value\nin a new file named descriptor.pb.\n\n$protoc --include_imports --include_source_info test.proto -o descriptor.pb",
          "type": "string",
          "format": "byte"
        }
      }
    },
    "Operation": {
      "id": "Operation",
      "description": "This resource represents a long-running operation that is the result of a\nnetwork API call.",
      "type": "object",
      "properties": {
        "name": {
          "description": "The server-assigned name, which is only unique within the same service that\noriginally returns it. If you use the default HTTP mapping, the\n`name` should have the format of `operations\/some\/unique\/name`.",
          "type": "string"
        },
        "metadata": {
          "description": "Service-specific metadata associated with the operation.  It typically\ncontains progress information and common metadata such as create time.\nSome services might not provide such metadata.  Any method that returns a\nlong-running operation should document the metadata type, if any.",
          "type": "object",
          "additionalProperties": {
            "type": "any",
            "description": "Properties of the object. Contains field @type with type URL."
          }
        },
        "done": {
          "description": "If the value is `false`, it means the operation is still in progress.\nIf true, the operation is completed, and either `error` or `response` is\navailable.",
          "type": "boolean"
        },
        "error": {
          "description": "The error result of the operation in case of failure.",
          "$ref": "Status"
        },
        "response": {
          "description": "The normal response of the operation in case of success.  If the original\nmethod returns no data on success, such as `Delete`, the response is\n`google.protobuf.Empty`.  If the original method is standard\n`Get`\/`Create`\/`Update`, the response should be the resource.  For other\nmethods, the response should have the type `XxxResponse`, where `Xxx`\nis the original method name.  For example, if the original method name\nis `TakeSnapshot()`, the inferred response type is\n`TakeSnapshotResponse`.",
          "type": "object",
          "additionalProperties": {
            "type": "any",
            "description": "Properties of the object. Contains field @type with type URL."
          }
        }
      }
    },
    "Status": {
      "id": "Status",
      "description": "The `Status` type defines a logical error model that is suitable for different\nprogramming environments, including REST APIs and RPC APIs. It is used by\n[gRPC](https:\/\/github.com\/grpc). The error model is designed to be:\n\n- Simple to use and understand for most users\n- Flexible enough to meet unexpected needs\n\n# Overview\n\nThe `Status` message contains three pieces of data: error code, error message,\nand error details. The error code should be an enum value of\ngoogle.rpc.Code, but it may accept additional error codes if needed.  The\nerror message should be a developer-facing English message that helps\ndevelopers *understand* and *resolve* the error. If a localized user-facing\nerror message is needed, put the localized message in the error details or\nlocalize it in the client. The optional error details may contain arbitrary\ninformation about the error. There is a predefined set of error detail types\nin the package `google.rpc` which can be used for common error conditions.\n\n# Language mapping\n\nThe `Status` message is the logical representation of the error model, but it\nis not necessarily the actual wire format. When the `Status` message is\nexposed in different client libraries and different wire protocols, it can be\nmapped differently. For example, it will likely be mapped to some exceptions\nin Java, but more likely mapped to some error codes in C.\n\n# Other uses\n\nThe error model and the `Status` message can be used in a variety of\nenvironments, either with or without APIs, to provide a\nconsistent developer experience across different environments.\n\nExample uses of this error model include:\n\n- Partial errors. If a service needs to return partial errors to the client,\n    it may embed the `Status` in the normal response to indicate the partial\n    errors.\n\n- Workflow errors. A typical workflow has multiple steps. Each step may\n    have a `Status` message for error reporting purpose.\n\n- Batch operations. If a client uses batch request and batch response, the\n    `Status` message should be used directly inside batch response, one for\n    each error sub-response.\n\n- Asynchronous operations. If an API call embeds asynchronous operation\n    results in its response, the status of those operations should be\n    represented directly using the `Status` message.\n\n- Logging. If some API errors are stored in logs, the message `Status` could\n    be used directly after any stripping needed for security\/privacy reasons.",
      "type": "object",
      "properties": {
        "code": {
          "description": "The status code, which should be an enum value of google.rpc.Code.",
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "description": "A developer-facing error message, which should be in English. Any\nuser-facing error message should be localized and sent in the\ngoogle.rpc.Status.details field, or localized by the client.",
          "type": "string"
        },
        "details": {
          "description": "A list of messages that carry the error details.  There will be a\ncommon set of message types for APIs to use.",
          "type": "array",
          "items": {
            "type": "object",
            "additionalProperties": {
              "type": "any",
              "description": "Properties of the object. Contains field @type with type URL."
            }
          }
        }
      }
    },
    "ProjectSettings": {
      "id": "ProjectSettings",
      "description": "Settings that control how a consumer project uses a service.",
      "type": "object",
      "properties": {
        "serviceName": {
          "description": "The name of the service.  See the `ServiceManager` overview for naming\nrequirements.",
          "type": "string"
        },
        "consumerProjectId": {
          "description": "ID for the project consuming this service.",
          "type": "string"
        },
        "usageSettings": {
          "description": "Settings that control whether this service is usable by the consumer\nproject.",
          "$ref": "UsageSettings"
        },
        "quotaSettings": {
          "description": "Settings that control how much or how fast the service can be used by the\nconsumer project.",
          "$ref": "QuotaSettings"
        },
        "visibilitySettings": {
          "description": "Settings that control which features of the service are visible to the\nconsumer project.",
          "$ref": "VisibilitySettings"
        },
        "properties": {
          "description": "Service-defined per-consumer properties.\n\nA key-value mapping a string key to a google.protobuf.ListValue proto.\nValues in the list are typed as defined in the Service configuration's\nconsumer.properties field.",
          "type": "object",
          "additionalProperties": {
            "type": "array",
            "items": {
              "type": "any"
            }
          }
        },
        "operations": {
          "description": "Read-only view of pending operations affecting this resource, if requested.",
          "type": "array",
          "items": {
            "$ref": "Operation"
          }
        }
      }
    },
    "UsageSettings": {
      "id": "UsageSettings",
      "description": "Usage settings for a consumer of a service.",
      "type": "object",
      "properties": {
        "consumerEnableStatus": {
          "description": "Consumer controlled setting to enable\/disable use of this service by the\nconsumer project. The default value of this is controlled by the service\nconfiguration.",
          "enumDescriptions": [
            "The service is disabled.",
            "The service is enabled."
          ],
          "type": "string",
          "enum": [
            "DISABLED",
            "ENABLED"
          ]
        }
      }
    },
    "QuotaSettings": {
      "id": "QuotaSettings",
      "description": "Per-consumer overrides for quota settings. See google\/api\/quota.proto\nfor the corresponding service configuration which provides the default\nvalues.",
      "type": "object",
      "properties": {
        "consumerOverrides": {
          "description": "Quota overrides set by the consumer. Consumer overrides will only have\nan effect up to the max_limit specified in the service config, or the\nthe producer override, if one exists.\n\nThe key for this map is one of the following:\n\n- '<GROUP_NAME>\/<LIMIT_NAME>' for quotas defined within quota groups,\nwhere GROUP_NAME is the google.api.QuotaGroup.name field and\nLIMIT_NAME is the google.api.QuotaLimit.name field from the service\nconfig.  For example: 'ReadGroup\/ProjectDaily'.\n\n- '<LIMIT_NAME>' for quotas defined without quota groups, where LIMIT_NAME\nis the google.api.QuotaLimit.name field from the service config. For\nexample: 'borrowedCountPerOrganization'.",
          "type": "object",
          "additionalProperties": {
            "$ref": "QuotaLimitOverride"
          }
        },
        "producerOverrides": {
          "description": "Quota overrides set by the producer. Note that if a consumer override is\nalso specified, then the minimum of the two will be used. This allows\nconsumers to cap their usage voluntarily.\n\nThe key for this map is one of the following:\n\n- '<GROUP_NAME>\/<LIMIT_NAME>' for quotas defined within quota groups,\nwhere GROUP_NAME is the google.api.QuotaGroup.name field and\nLIMIT_NAME is the google.api.QuotaLimit.name field from the service\nconfig.  For example: 'ReadGroup\/ProjectDaily'.\n\n- '<LIMIT_NAME>' for quotas defined without quota groups, where LIMIT_NAME\nis the google.api.QuotaLimit.name field from the service config. For\nexample: 'borrowedCountPerOrganization'.",
          "type": "object",
          "additionalProperties": {
            "$ref": "QuotaLimitOverride"
          }
        },
        "effectiveQuotas": {
          "description": "The effective quota limits for each group, derived from the service\ndefaults together with any producer or consumer overrides.\nFor each limit, the effective value is the minimum of the producer\nand consumer overrides if either is present, or else the service default\nif neither is present.\nDEPRECATED. Use effective_quota_groups instead.",
          "type": "object",
          "additionalProperties": {
            "$ref": "QuotaLimitOverride"
          }
        },
        "variableTermQuotas": {
          "description": "Quotas that are active over a specified time period. Only writeable\nby the producer.",
          "type": "array",
          "items": {
            "$ref": "VariableTermQuota"
          }
        },
        "effectiveQuotaGroups": {
          "description": "Use this field for quota limits defined under quota groups.\nCombines service quota configuration and project-specific settings, as\na map from quota group name to the effective quota information for that\ngroup.\nOutput-only.",
          "type": "array",
          "items": {
            "$ref": "EffectiveQuotaGroup"
          }
        }
      }
    },
    "QuotaLimitOverride": {
      "id": "QuotaLimitOverride",
      "description": "Specifies a custom quota limit that is applied for this consumer project.\nThis overrides the default value in google.api.QuotaLimit.",
      "type": "object",
      "properties": {
        "limit": {
          "description": "The new limit for this project.\nMay be -1 (unlimited), 0 (block), or any positive integer.",
          "type": "string",
          "format": "int64"
        },
        "unlimited": {
          "description": "Indicates the override is to provide unlimited quota.  If true,\nany value set for limit will be ignored.\nDEPRECATED. Use a limit value of -1 instead.",
          "type": "boolean"
        }
      }
    },
    "VariableTermQuota": {
      "id": "VariableTermQuota",
      "description": "A variable term quota is a bucket of tokens that is consumed over a\nspecified (usually long) time period. When present, it overrides any\n\"1d\" duration per-project quota specified on the group.\n\nVariable terms run from midnight to midnight, start_date to end_date\n(inclusive) in the America\/Los_Angeles time zone.",
      "type": "object",
      "properties": {
        "groupName": {
          "description": "The quota group that has the variable term quota applied to it.\nThis must be a google.api.QuotaGroup.name specified in the\nservice configuration.",
          "type": "string"
        },
        "startDate": {
          "description": "The beginning of the active period for the variable term quota.\nYYYYMMdd date format, e.g. 20140730.",
          "type": "string"
        },
        "endDate": {
          "description": "The effective end of the active period for the variable term quota\n(inclusive). This must be no more than 5 years after start_date.\nYYYYMMdd date format, e.g. 20140730.",
          "type": "string"
        },
        "displayEndDate": {
          "description": "The displayed end of the active period for the variable term quota.\nThis may be before the effective end to give the user a grace period.\nYYYYMMdd date format, e.g. 20140730.",
          "type": "string"
        },
        "createTime": {
          "description": "Time when this variable term quota was created. If multiple quotas\nare simultaneously active, then the quota with the latest create_time\nis the effective one.",
          "type": "string",
          "format": "google-datetime"
        },
        "limit": {
          "description": "The number of tokens available during the configured term.",
          "type": "string",
          "format": "int64"
        },
        "quotaUsage": {
          "description": "The usage data of this quota.",
          "$ref": "QuotaUsage"
        }
      }
    },
    "QuotaUsage": {
      "id": "QuotaUsage",
      "description": "Specifies the used quota amount for a quota limit at a particular time.",
      "type": "object",
      "properties": {
        "usage": {
          "description": "The used quota value at the \"query_time\".",
          "type": "string",
          "format": "int64"
        },
        "startTime": {
          "description": "The time the quota duration started.",
          "type": "string",
          "format": "google-datetime"
        },
        "endTime": {
          "description": "The time the quota duration ended.",
          "type": "string",
          "format": "google-datetime"
        },
        "queryTime": {
          "description": "The time the quota usage data was queried.",
          "type": "string",
          "format": "google-datetime"
        }
      }
    },
    "EffectiveQuotaGroup": {
      "id": "EffectiveQuotaGroup",
      "description": "An effective quota group contains both the metadata for a quota group\nas derived from the service config, and the effective limits in that\ngroup as calculated from producer and consumer overrides together with\nservice defaults.",
      "type": "object",
      "properties": {
        "baseGroup": {
          "description": "The service configuration for this quota group, minus the quota limits,\nwhich are replaced by the effective limits below.",
          "$ref": "QuotaGroup"
        },
        "billingInteraction": {

          "enumDescriptions": [
            "The interaction between this quota group and the project billing status\nis unspecified.",
            "This quota group is enforced only when the consumer project\nis not billable.",
            "This quota group is enforced only when the consumer project\nis billable.",
            "This quota group is enforced regardless of the consumer project's\nbilling status."
          ],
          "type": "string",
          "enum": [
            "BILLING_INTERACTION_UNSPECIFIED",
            "NONBILLABLE_ONLY",
            "BILLABLE_ONLY",
            "ANY_BILLING_STATUS"
          ]
        },
        "quotas": {
          "description": "The usage and limit information for each limit within this quota group.",
          "type": "array",
          "items": {
            "$ref": "QuotaInfo"
          }
        }
      }
    },
    "QuotaInfo": {
      "id": "QuotaInfo",
      "description": "Metadata about an individual quota, containing usage and limit information.",
      "type": "object",
      "properties": {
        "limit": {
          "description": "The effective limit for this quota.",
          "$ref": "EffectiveQuotaLimit"
        },
        "currentUsage": {
          "description": "The usage data for this quota as it applies to the current limit.",
          "$ref": "QuotaUsage"
        },
        "historicalUsage": {
          "description": "The historical usage data of this quota limit. Currently it is only\navailable for daily quota limit, that is, base_limit.duration = \"1d\".",
          "type": "array",
          "items": {
            "$ref": "QuotaUsage"
          }
        }
      }
    },
    "EffectiveQuotaLimit": {
      "id": "EffectiveQuotaLimit",
      "description": "An effective quota limit contains the metadata for a quota limit\nas derived from the service config, together with fields that describe\nthe effective limit value and what overrides can be applied to it.",
      "type": "object",
      "properties": {
        "baseLimit": {
          "description": "The service's configuration for this quota limit.",
          "$ref": "QuotaLimit"
        },
        "key": {
          "description": "The key used to identify this limit when applying overrides.\nThe consumer_overrides and producer_overrides maps are keyed\nby strings of the form \"QuotaGroupName\/QuotaLimitName\".",
          "type": "string"
        },
        "maxConsumerOverrideAllowed": {
          "description": "The maximum override value that a consumer may specify.",
          "type": "string",
          "format": "int64"
        },
        "effectiveLimit": {
          "description": "The effective limit value, based on the stored producer and consumer\noverrides and the service defaults.",
          "type": "string",
          "format": "int64"
        }
      }
    },
    "VisibilitySettings": {
      "id": "VisibilitySettings",
      "description": "Settings that control which features of the service are visible to the\nconsumer project.",
      "type": "object",
      "properties": {
        "visibilityLabels": {
          "description": "The set of visibility labels that are used to determine what API surface is\nvisible to calls made by this project. The visible surface is a union of\nthe surface features associated with each label listed here, plus the\npublicly visible (unrestricted) surface.\n\nThe service producer may add or remove labels at any time. The service\nconsumer may add a label if the calling user has been granted permission\nto do so by the producer.  The service consumer may also remove any label\nat any time.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "ListServiceConfigsResponse": {
      "id": "ListServiceConfigsResponse",
      "description": "Response message for ListServiceConfigs method.",
      "type": "object",
      "properties": {
        "serviceConfigs": {
          "description": "The list of service config resources.",
          "type": "array",
          "items": {
            "$ref": "Service"
          }
        },
        "nextPageToken": {
          "description": "The token of the next page of results.",
          "type": "string"
        }
      }
    },
    "SubmitConfigSourceRequest": {
      "id": "SubmitConfigSourceRequest",
      "description": "Request message for SubmitConfigSource method.",
      "type": "object",
      "properties": {
        "configSource": {
          "description": "The source configuration for the service.",
          "$ref": "ConfigSource"
        },
        "validateOnly": {
          "description": "Optional. If set, this will result in the generation of a\n`google.api.Service` configuration based on the `ConfigSource` provided,\nbut the generated config and the sources will NOT be persisted.",
          "type": "boolean"
        }
      }
    },
    "ConvertConfigRequest": {
      "id": "ConvertConfigRequest",
      "description": "Request message for `ConvertConfig` method.",
      "type": "object",
      "properties": {
        "swaggerSpec": {
          "description": "The swagger specification for an API.",
          "$ref": "SwaggerSpec"
        },
        "openApiSpec": {
          "description": "The OpenAPI specification for an API.",
          "$ref": "OpenApiSpec"
        },
        "serviceName": {
          "description": "The service name to use for constructing the normalized service\nconfiguration equivalent of the provided configuration specification.",
          "type": "string"
        },
        "configSpec": {
          "description": "Input configuration\nFor this version of API, the supported type is OpenApiSpec",
          "type": "object",
          "additionalProperties": {
            "type": "any",
            "description": "Properties of the object. Contains field @type with type URL."
          }
        }
      }
    },
    "SwaggerSpec": {
      "id": "SwaggerSpec",
      "description": "A collection of swagger specification files.",
      "type": "object",
      "properties": {
        "swaggerFiles": {
          "description": "The individual files.",
          "type": "array",
          "items": {
            "$ref": "File"
          }
        }
      }
    },
    "File": {
      "id": "File",
      "description": "A single swagger specification file.",
      "type": "object",
      "properties": {
        "path": {
          "description": "The relative path of the swagger spec file.",
          "type": "string"
        },
        "contents": {
          "description": "The contents of the swagger spec file.",
          "type": "string"
        }
      }
    },
    "ConvertConfigResponse": {
      "id": "ConvertConfigResponse",
      "description": "Response message for `ConvertConfig` method.",
      "type": "object",
      "properties": {
        "serviceConfig": {
          "description": "The service configuration. Not set if errors occured during conversion.",
          "$ref": "Service"
        },
        "diagnostics": {
          "description": "Any errors or warnings that occured during config conversion.",
          "type": "array",
          "items": {
            "$ref": "Diagnostic"
          }
        }
      }
    },
    "Diagnostic": {
      "id": "Diagnostic",
      "description": "A collection that represents a diagnostic message (error or warning)",
      "type": "object",
      "properties": {
        "location": {
          "description": "Location of the cause or context of the diagnostic information.",
          "type": "string"
        },
        "kind": {
          "description": "The kind of diagnostic information provided.",
          "enumDescriptions": [
            "Warnings and errors",
            "Only errors"
          ],
          "type": "string",
          "enum": [
            "WARNING",
            "ERROR"
          ]
        },
        "message": {
          "description": "The string message of the diagnostic information.",
          "type": "string"
        }
      }
    },
    "EnableServiceRequest": {
      "id": "EnableServiceRequest",
      "description": "Request message for EnableService method.",
      "type": "object",
      "properties": {
        "consumerId": {
          "description": "The identity of consumer resource which service enablement will be\napplied to.\n\nThe Google Service Management implementation accepts the following\nforms: \"project:<project_id>\", \"project_number:<project_number>\".\n\nNote: this is made compatible with\ngoogle.api.servicecontrol.v1.Operation.consumer_id.",
          "type": "string"
        }
      }
    },
    "DisableServiceRequest": {
      "id": "DisableServiceRequest",
      "description": "Request message for DisableService method.",
      "type": "object",
      "properties": {
        "consumerId": {
          "description": "The identity of consumer resource which service disablement will be\napplied to.\n\nThe Google Service Management implementation accepts the following\nforms: \"project:<project_id>\", \"project_number:<project_number>\".\n\nNote: this is made compatible with\ngoogle.api.servicecontrol.v1.Operation.consumer_id.",
          "type": "string"
        }
      }
    },
    "ServiceAccessPolicy": {
      "id": "ServiceAccessPolicy",
      "description": "Policy describing who can access a service and any visibility labels on that\nservice.",
      "type": "object",
      "properties": {
        "serviceName": {
          "description": "The service protected by this policy.",
          "type": "string"
        },
        "accessList": {
          "description": "ACL for access to the unrestricted surface of the service.",
          "$ref": "ServiceAccessList"
        },
        "visibilityLabelAccessLists": {
          "description": "ACLs for access to restricted parts of the service.  The map key is the\nvisibility label that is being controlled.  Note that access to any label\nalso implies access to the unrestricted surface.",
          "type": "object",
          "additionalProperties": {
            "$ref": "ServiceAccessList"
          }
        }
      }
    },
    "ServiceAccessList": {
      "id": "ServiceAccessList",
      "description": "List of users and groups that are granted access to a service or visibility\nlabel.",
      "type": "object",
      "properties": {
        "members": {
          "description": "Members that are granted access.\n\n- \"user:{$user_email}\" - Grant access to an individual user\n- \"group:{$group_email}\" - Grant access to direct members of the group\n- \"domain:{$domain}\" - Grant access to all members of the domain. For now,\n     domain membership check will be similar to Devconsole\/TT check:\n     compare domain part of the user email to configured domain name.\n     When IAM integration is complete, this will be replaced with IAM\n     check.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "QueryUserAccessResponse": {
      "id": "QueryUserAccessResponse",
      "description": "Request message for QueryUserAccess method.",
      "type": "object",
      "properties": {
        "canAccessService": {
          "description": "True if the user can access the service and any unrestricted API surface.",
          "type": "boolean"
        },
        "accessibleVisibilityLabels": {
          "description": "Any visibility labels on the service that are accessible by the user.",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      }
    },
    "CustomerSettings": {
      "id": "CustomerSettings",
      "description": "Settings that control how a customer (identified by a billing account) uses\na service",
      "type": "object",
      "properties": {
        "serviceName": {
          "description": "The name of the service.  See the `ServiceManager` overview for naming\nrequirements.",
          "type": "string"
        },
        "customerId": {
          "description": "ID for the customer that consumes the service (see above).\nThe supported types of customers are:\n\n1. domain:{domain}\nA Google Apps domain name. For example, google.com.\n\n2. billingAccount:{billing_account_id}\nA Google Cloud Plafrom billing account. For Example, 123456-7890ab-cdef12.\n",
          "type": "string"
        },
        "quotaSettings": {
          "description": "Settings that control how much or how fast the service can be used by the\nconsumer projects owned by the customer collectively.",
          "$ref": "QuotaSettings"
        }
      }
    },
    "CompositeOperationMetadata": {
      "id": "CompositeOperationMetadata",
      "description": "Metadata for composite operations.",
      "type": "object",
      "properties": {
        "childOperations": {
          "description": "The child operations. The details of the asynchronous\nchild operations are stored in a separate row and not in this\nmetadata. Only the operation name is stored here.",
          "type": "array",
          "items": {
            "$ref": "Operation"
          }
        },
        "originalRequest": {
          "description": "Original request that triggered this operation.",
          "type": "object",
          "additionalProperties": {
            "type": "any",
            "description": "Properties of the object. Contains field @type with type URL."
          }
        },
        "responseFieldMasks": {
          "description": "Defines which part of the response a child operation will contribute.\nEach key of the map is the name of a child operation. Each value is a\nfield mask that identifies what that child operation contributes to the\nresponse, for example, \"quota_settings\", \"visiblity_settings\", etc.",
          "type": "object",
          "additionalProperties": {
            "type": "string",
            "format": "google-fieldmask"
          }
        },
        "persisted": {
          "description": "Indicates whether the requested state change has been persisted. Once this\nfield is set, it is guaranteed to propagate to all backends eventually, but\nit may not be visible immediately. Clients that are not concerned with\nwaiting on propagation can stop polling the operation once the persisted\nfield is set",
          "type": "boolean"
        }
      }
    },
    "OperationMetadata": {
      "id": "OperationMetadata",
      "description": "The metadata associated with a long running operation resource.",
      "type": "object",
      "properties": {
        "resourceNames": {
          "description": "The full name of the resources that this operation is directly\nassociated with.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "steps": {
          "description": "Detailed status information for each step. The order is undetermined.",
          "type": "array",
          "items": {
            "$ref": "Step"
          }
        },
        "progressPercentage": {
          "description": "Percentage of completion of this operation, ranging from 0 to 100.",
          "type": "integer",
          "format": "int32"
        },
        "startTime": {
          "description": "The start time of the operation.",
          "type": "string",
          "format": "google-datetime"
        }
      }
    },
    "Step": {
      "id": "Step",
      "description": "Represents the status of one operation step.",
      "type": "object",
      "properties": {
        "description": {
          "description": "The short description of the step.",
          "type": "string"
        },
        "status": {
          "description": "The status code.",
          "enumDescriptions": [
            "Unspecifed code.",
            "The step has completed without errors.",
            "The step has not started yet.",
            "The step is in progress.",
            "The step has completed with errors."
          ],
          "type": "string",
          "enum": [
            "STATUS_UNSPECIFIED",
            "DONE",
            "NOT_STARTED",
            "IN_PROGRESS",
            "FAILED"
          ]
        }
      }
    }
  },
  "resources": {
    "services": {
      "methods": {
        "list": {
          "id": "servicemanagement.services.list",
          "path": "v1/services",
          "flatPath": "v1/services",
          "httpMethod": "GET",
          "description": "Lists all managed services. If the `consumer_project_id` is specified,\nthe project's settings for the specified service are also returned.",
          "parameters": {
            "producerProjectId": {
              "description": "Include services produced by the specified project.",
              "location": "query",
              "type": "string"
            },
            "category": {
              "description": "Include services only in the specified category. Supported categories are\nservicemanagement.googleapis.com\/categories\/google-services or\nservicemanagement.googleapis.com\/categories\/play-games.",
              "location": "query",
              "type": "string"
            },
            "consumerProjectId": {
              "description": "Include services consumed by the specified project.\n\nIf project_settings is expanded, then this field controls which project\nproject_settings is populated for.",
              "location": "query",
              "type": "string"
            },
            "expand": {
              "description": "Fields to expand in any results.  By default, the following fields\nare not fully included in list results:\n- `operations`\n- `project_settings`\n- `project_settings.operations`\n- `quota_usage` (It requires `project_settings`)",
              "location": "query",
              "type": "string",
              "format": "google-fieldmask"
            },
            "pageSize": {
              "description": "Requested size of the next page of data.",
              "location": "query",
              "type": "integer",
              "format": "int32"
            },
            "pageToken": {
              "description": "Token identifying which result to start with; returned by a previous list\ncall.",
              "location": "query",
              "type": "string"
            }
          },
          "parameterOrder": [
          ],
          "response": {
            "$ref": "ListServicesResponse"
          },
          "scopes": [
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/service.management"
          ]
        },
        "get": {
          "id": "servicemanagement.services.get",
          "path": "v1/services/{serviceName}",
          "flatPath": "v1/services/{serviceName}",
          "httpMethod": "GET",
          "description": "Gets a managed service. If the `consumer_project_id` is specified,\nthe project's settings for the specified service are also returned.",
          "parameters": {
            "serviceName": {
              "description": "The name of the service.  See the `ServiceManager` overview for naming\nrequirements.  For example: `example.googleapis.com`.",
              "location": "path",
              "required": true,
              "type": "string"
            },
            "expand": {
              "description": "Fields to expand in any results.  By default, the following fields\nare not present in the result:\n- `operations`\n- `project_settings`\n- `project_settings.operations`\n- `quota_usage` (It requires `project_settings`)\n- `historical_quota_usage` (It requires `project_settings`)",
              "location": "query",
              "type": "string",
              "format": "google-fieldmask"
            },
            "consumerProjectId": {
              "description": "If project_settings is expanded, return settings for the specified\nconsumer project.",
              "location": "query",
              "type": "string"
            },
            "view": {
              "description": "If project_settings is expanded, request only fields for the specified\nview.",
              "location": "query",
              "type": "string",
              "enum": [
                "PROJECT_SETTINGS_VIEW_UNSPECIFIED",
                "CONSUMER_VIEW",
                "PRODUCER_VIEW",
                "ALL"
              ]
            }
          },
          "parameterOrder": [
            "serviceName"
          ],
          "response": {
            "$ref": "ManagedService"
          },
          "scopes": [
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/service.management"
          ]
        },
        "create": {
          "id": "servicemanagement.services.create",
          "path": "v1/services",
          "flatPath": "v1/services",
          "httpMethod": "POST",
          "description": "Creates a new managed service.\n\nOperation<response: ManagedService>",
          "parameters": {
          },
          "parameterOrder": [
          ],
          "request": {
            "$ref": "ManagedService"
          },
          "response": {
            "$ref": "Operation"
          },
          "scopes": [
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/service.management"
          ]
        },
        "delete": {
          "id": "servicemanagement.services.delete",
          "path": "v1/services/{serviceName}",
          "flatPath": "v1/services/{serviceName}",
          "httpMethod": "DELETE",
          "description": "Deletes a managed service.\n\nOperation<response: google.protobuf.Empty>",
          "parameters": {
            "serviceName": {
              "description": "The name of the service.  See the `ServiceManager` overview for naming\nrequirements.  For example: `example.googleapis.com`.",
              "location": "path",
              "required": true,
              "type": "string"
            }
          },
          "parameterOrder": [
            "serviceName"
          ],
          "response": {
            "$ref": "Operation"
          },
          "scopes": [
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/service.management"
          ]
        },
        "getConfig": {
          "id": "servicemanagement.services.getConfig",
          "path": "v1/services/{serviceName}/config",
          "flatPath": "v1/services/{serviceName}/config",
          "httpMethod": "GET",
          "description": "Gets a service config (version) for a managed service. If `config_id` is\nnot specified, the latest service config will be returned.",
          "parameters": {
            "serviceName": {
              "description": "The name of the service.  See the `ServiceManager` overview for naming\nrequirements.  For example: `example.googleapis.com`.",
              "location": "path",
              "required": true,
              "type": "string"
            },
            "configId": {
              "description": "The id of the service config resource.\nOptional. If it is not specified, the latest version of config will be\nreturned.",
              "location": "query",
              "type": "string"
            }
          },
          "parameterOrder": [
            "serviceName"
          ],
          "response": {
            "$ref": "Service"
          },
          "scopes": [
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/service.management"
          ]
        },
        "convertConfig": {
          "id": "servicemanagement.services.convertConfig",
          "path": "v1/services:convertConfig",
          "flatPath": "v1/services:convertConfig",
          "httpMethod": "POST",
          "description": "DEPRECATED. `SubmitConfigSource` with `validate_only=true` will provide\nconfig conversion moving forward.\n\nConverts an API specification (e.g. Swagger spec) to an\nequivalent `google.api.Service`.",
          "parameters": {
          },
          "parameterOrder": [
          ],
          "request": {
            "$ref": "ConvertConfigRequest"
          },
          "response": {
            "$ref": "ConvertConfigResponse"
          },
          "scopes": [
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/service.management"
          ]
        },
        "enable": {
          "id": "servicemanagement.services.enable",
          "path": "v1/services/{serviceName}:enable",
          "flatPath": "v1/services/{serviceName}:enable",
          "httpMethod": "POST",
          "description": "Enable a managed service for a project with default setting.\nIf the managed service has dependencies, they will be enabled as well.\n\nOperation<response: EnableServiceResponse>\n",
          "parameters": {
            "serviceName": {
              "description": "Name of the service to enable. Specifying an unknown service name will\ncause the request to fail.",
              "location": "path",
              "required": true,
              "type": "string"
            }
          },
          "parameterOrder": [
            "serviceName"
          ],
          "request": {
            "$ref": "EnableServiceRequest"
          },
          "response": {
            "$ref": "Operation"
          },
          "scopes": [
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/service.management"
          ]
        },
        "disable": {
          "id": "servicemanagement.services.disable",
          "path": "v1/services/{serviceName}:disable",
          "flatPath": "v1/services/{serviceName}:disable",
          "httpMethod": "POST",
          "description": "Disable a managed service for a project.\nGoogle Service Management will only disable the managed service even if\nthere are other services depend on the managed service.\n\nOperation<response: DisableServiceResponse>\n",
          "parameters": {
            "serviceName": {
              "description": "Name of the service to disable. Specifying an unknown service name\nwill cause the request to fail.",
              "location": "path",
              "required": true,
              "type": "string"
            }
          },
          "parameterOrder": [
            "serviceName"
          ],
          "request": {
            "$ref": "DisableServiceRequest"
          },
          "response": {
            "$ref": "Operation"
          },
          "scopes": [
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/service.management"
          ]
        },
        "update": {
          "id": "servicemanagement.services.update",
          "path": "v1/services/{serviceName}",
          "flatPath": "v1/services/{serviceName}",
          "httpMethod": "PUT",
          "description": "Updates the configuration of a service.  If the specified service does not\nalready exist, then it is created.\n\nOperation<response: ManagedService>",
          "parameters": {
            "serviceName": {
              "description": "The name of the service.  See the `ServiceManager` overview for naming\nrequirements.  For example: `example.googleapis.com`.",
              "location": "path",
              "required": true,
              "type": "string"
            },
            "updateMask": {
              "description": "A mask specifying which fields to update.\nUpdate mask has been deprecated on UpdateService service method. Please\nuse PatchService method instead to do partial updates.",
              "location": "query",
              "type": "string",
              "format": "google-fieldmask"
            }
          },
          "parameterOrder": [
            "serviceName"
          ],
          "request": {
            "$ref": "ManagedService"
          },
          "response": {
            "$ref": "Operation"
          },
          "scopes": [
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/service.management"
          ]
        },
        "patch": {
          "id": "servicemanagement.services.patch",
          "path": "v1/services/{serviceName}",
          "flatPath": "v1/services/{serviceName}",
          "httpMethod": "PATCH",
          "description": "Updates the specified subset of the configuration. If the specified service\ndoes not exists the patch operation fails.\n\nOperation<response: ManagedService>",
          "parameters": {
            "serviceName": {
              "description": "The name of the service.  See the `ServiceManager` overview for naming\nrequirements.  For example: `example.googleapis.com`.",
              "location": "path",
              "required": true,
              "type": "string"
            },
            "updateMask": {
              "description": "A mask specifying which fields to update.",
              "location": "query",
              "type": "string",
              "format": "google-fieldmask"
            }
          },
          "parameterOrder": [
            "serviceName"
          ],
          "request": {
            "$ref": "ManagedService"
          },
          "response": {
            "$ref": "Operation"
          },
          "scopes": [
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/service.management"
          ]
        },
        "updateConfig": {
          "id": "servicemanagement.services.updateConfig",
          "path": "v1/services/{serviceName}/config",
          "flatPath": "v1/services/{serviceName}/config",
          "httpMethod": "PUT",
          "description": "Updates the specified subset of the service resource. Equivalent to\ncalling `UpdateService` with only the `service_config` field updated.\n\nOperation<response: google.api.Service>",
          "parameters": {
            "serviceName": {
              "description": "The name of the service.  See the `ServiceManager` overview for naming\nrequirements.  For example: `example.googleapis.com`.",
              "location": "path",
              "required": true,
              "type": "string"
            },
            "updateMask": {
              "description": "A mask specifying which fields to update.\nUpdate mask has been deprecated on UpdateServiceConfig service method.\nPlease use PatchServiceConfig method instead to do partial updates.",
              "location": "query",
              "type": "string",
              "format": "google-fieldmask"
            }
          },
          "parameterOrder": [
            "serviceName"
          ],
          "request": {
            "$ref": "Service"
          },
          "response": {
            "$ref": "Operation"
          },
          "scopes": [
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/service.management"
          ]
        },
        "patchConfig": {
          "id": "servicemanagement.services.patchConfig",
          "path": "v1/services/{serviceName}/config",
          "flatPath": "v1/services/{serviceName}/config",
          "httpMethod": "PATCH",
          "description": "Updates the specified subset of the service resource. Equivalent to\ncalling `PatchService` with only the `service_config` field updated.\n\nOperation<response: google.api.Service>",
          "parameters": {
            "serviceName": {
              "description": "The name of the service.  See the `ServiceManager` overview for naming\nrequirements.  For example: `example.googleapis.com`.",
              "location": "path",
              "required": true,
              "type": "string"
            },
            "updateMask": {
              "description": "A mask specifying which fields to update.",
              "location": "query",
              "type": "string",
              "format": "google-fieldmask"
            }
          },
          "parameterOrder": [
            "serviceName"
          ],
          "request": {
            "$ref": "Service"
          },
          "response": {
            "$ref": "Operation"
          },
          "scopes": [
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/service.management"
          ]
        },
        "getAccessPolicy": {
          "id": "servicemanagement.services.getAccessPolicy",
          "path": "v1/services/{serviceName}/accessPolicy",
          "flatPath": "v1/services/{serviceName}/accessPolicy",
          "httpMethod": "GET",
          "description": "Producer method to retrieve current policy.",
          "parameters": {
            "serviceName": {
              "description": "The name of the service.  For example: `example.googleapis.com`.",
              "location": "path",
              "required": true,
              "type": "string"
            }
          },
          "parameterOrder": [
            "serviceName"
          ],
          "response": {
            "$ref": "ServiceAccessPolicy"
          },
          "scopes": [
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/service.management"
          ]
        },
        "updateAccessPolicy": {
          "id": "servicemanagement.services.updateAccessPolicy",
          "path": "v1/services/{serviceName}/accessPolicy",
          "flatPath": "v1/services/{serviceName}/accessPolicy",
          "httpMethod": "PUT",
          "description": "Producer method to update the current policy.  This method will return an\nerror if the policy is too large (more than 50 entries across all lists).",
          "parameters": {
            "serviceName": {
              "description": "The name of the service.  For example: `example.googleapis.com`.\nIf set, policy's service_name should be same as this one.",
              "location": "path",
              "required": true,
              "type": "string"
            }
          },
          "parameterOrder": [
            "serviceName"
          ],
          "request": {
            "$ref": "ServiceAccessPolicy"
          },
          "response": {
            "$ref": "ServiceAccessPolicy"
          },
          "scopes": [
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/service.management"
          ]
        }
      }
      ,
      "resources": {
        "configs": {
          "methods": {
            "list": {
              "id": "servicemanagement.services.configs.list",
              "path": "v1/services/{serviceName}/configs",
              "flatPath": "v1/services/{serviceName}/configs",
              "httpMethod": "GET",
              "description": "Lists the history of the service config for a managed service,\nfrom the newest to the oldest.\n",
              "parameters": {
                "serviceName": {
                  "description": "The name of the service.  See the `ServiceManager` overview for naming\nrequirements.  For example: `example.googleapis.com`.",
                  "location": "path",
                  "required": true,
                  "type": "string"
                },
                "pageToken": {
                  "description": "The token of the page to retrieve.",
                  "location": "query",
                  "type": "string"
                },
                "pageSize": {
                  "description": "The max number of items to include in the response list.",
                  "location": "query",
                  "type": "integer",
                  "format": "int32"
                }
              },
              "parameterOrder": [
                "serviceName"
              ],
              "response": {
                "$ref": "ListServiceConfigsResponse"
              },
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/service.management"
              ]
            },
            "get": {
              "id": "servicemanagement.services.configs.get",
              "path": "v1/services/{serviceName}/configs/{configId}",
              "flatPath": "v1/services/{serviceName}/configs/{configId}",
              "httpMethod": "GET",
              "description": "Gets a service config (version) for a managed service. If `config_id` is\nnot specified, the latest service config will be returned.",
              "parameters": {
                "serviceName": {
                  "description": "The name of the service.  See the `ServiceManager` overview for naming\nrequirements.  For example: `example.googleapis.com`.",
                  "location": "path",
                  "required": true,
                  "type": "string"
                },
                "configId": {
                  "description": "The id of the service config resource.\nOptional. If it is not specified, the latest version of config will be\nreturned.",
                  "location": "path",
                  "required": true,
                  "type": "string"
                }
              },
              "parameterOrder": [
                "serviceName",
                "configId"
              ],
              "response": {
                "$ref": "Service"
              },
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/service.management"
              ]
            },
            "create": {
              "id": "servicemanagement.services.configs.create",
              "path": "v1/services/{serviceName}/configs",
              "flatPath": "v1/services/{serviceName}/configs",
              "httpMethod": "POST",
              "description": "Creates a new service config (version) for a managed service. This method\nonly stores the service config, but does not apply the service config to\nany backend services.\n",
              "parameters": {
                "serviceName": {
                  "description": "The name of the service.  See the `ServiceManager` overview for naming\nrequirements.  For example: `example.googleapis.com`.",
                  "location": "path",
                  "required": true,
                  "type": "string"
                }
              },
              "parameterOrder": [
                "serviceName"
              ],
              "request": {
                "$ref": "Service"
              },
              "response": {
                "$ref": "Service"
              },
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/service.management"
              ]
            },
            "submit": {
              "id": "servicemanagement.services.configs.submit",
              "path": "v1/services/{serviceName}/configs:submit",
              "flatPath": "v1/services/{serviceName}/configs:submit",
              "httpMethod": "POST",
              "description": "Creates a new service config (version) for a managed service based on\nuser-supplied configuration sources files (for example: OpenAPI\nSpecification). This method stores the source configurations as well as the\ngenerated service config. It does NOT apply the service config to any\nbackend services.\n\nOperation<response: SubmitConfigSourceResponse>\n",
              "parameters": {
                "serviceName": {
                  "description": "The name of the service.  See the `ServiceManager` overview for naming\nrequirements.  For example: `example.googleapis.com`.",
                  "location": "path",
                  "required": true,
                  "type": "string"
                }
              },
              "parameterOrder": [
                "serviceName"
              ],
              "request": {
                "$ref": "SubmitConfigSourceRequest"
              },
              "response": {
                "$ref": "Operation"
              },
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/service.management"
              ]
            }
          }
        },
        "accessPolicy": {
          "methods": {
            "query": {
              "id": "servicemanagement.services.accessPolicy.query",
              "path": "v1/services/{serviceName}/accessPolicy:query",
              "flatPath": "v1/services/{serviceName}/accessPolicy:query",
              "httpMethod": "POST",
              "description": "Method to query the accessibility of a service and any associated\nvisibility labels for a specified user.\n\nMembers of the producer project may call this method and specify any user.\n\nAny user may call this method, but must specify their own email address.\nIn this case the method will return NOT_FOUND if the user has no access to\nthe service.",
              "parameters": {
                "serviceName": {
                  "description": "The service to query access for.",
                  "location": "path",
                  "required": true,
                  "type": "string"
                },
                "userEmail": {
                  "description": "The user to query access for.",
                  "location": "query",
                  "type": "string"
                }
              },
              "parameterOrder": [
                "serviceName"
              ],
              "response": {
                "$ref": "QueryUserAccessResponse"
              },
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/service.management"
              ]
            }
          }
        },
        "customerSettings": {
          "methods": {
            "get": {
              "id": "servicemanagement.services.customerSettings.get",
              "path": "v1/services/{serviceName}/customerSettings/{customerId}",
              "flatPath": "v1/services/{serviceName}/customerSettings/{customerId}",
              "httpMethod": "GET",
              "description": "Retrieves the settings that control the specified customer's usage of the\nservice.",
              "parameters": {
                "serviceName": {
                  "description": "The name of the service.  See the `ServiceManager` overview for naming\nrequirements.  For example: `example.googleapis.com`. This field is\nrequired.",
                  "location": "path",
                  "required": true,
                  "type": "string"
                },
                "customerId": {
                  "description": "ID for the customer. See the comment for `CustomerSettings.customer_id`\nfield of message for its format. This field is required.",
                  "location": "path",
                  "required": true,
                  "type": "string"
                },
                "expand": {
                  "description": "Fields to expand in any results.",
                  "location": "query",
                  "type": "string",
                  "format": "google-fieldmask"
                },
                "view": {
                  "description": "Request only fields for the specified view.",
                  "location": "query",
                  "type": "string",
                  "enum": [
                    "PROJECT_SETTINGS_VIEW_UNSPECIFIED",
                    "CONSUMER_VIEW",
                    "PRODUCER_VIEW",
                    "ALL"
                  ]
                }
              },
              "parameterOrder": [
                "serviceName",
                "customerId"
              ],
              "response": {
                "$ref": "CustomerSettings"
              },
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/service.management"
              ]
            },
            "patch": {
              "id": "servicemanagement.services.customerSettings.patch",
              "path": "v1/services/{serviceName}/customerSettings/{customerId}",
              "flatPath": "v1/services/{serviceName}/customerSettings/{customerId}",
              "httpMethod": "PATCH",
              "description": "Updates specified subset of the settings that control the specified\ncustomer's usage of the service.  Attempts to update a field not\ncontrolled by the caller will result in an access denied error.\n\nOperation<response: CustomerSettings>",
              "parameters": {
                "serviceName": {
                  "description": "The name of the service.  See the `ServiceManager` overview for naming\nrequirements.  For example: `example.googleapis.com`. This field is\nrequired.",
                  "location": "path",
                  "required": true,
                  "type": "string"
                },
                "customerId": {
                  "description": "ID for the customer. See the comment for `CustomerSettings.customer_id`\nfield of message for its format. This field is required.",
                  "location": "path",
                  "required": true,
                  "type": "string"
                },
                "updateMask": {
                  "description": "The field mask specifying which fields are to be updated.",
                  "location": "query",
                  "type": "string",
                  "format": "google-fieldmask"
                }
              },
              "parameterOrder": [
                "serviceName",
                "customerId"
              ],
              "request": {
                "$ref": "CustomerSettings"
              },
              "response": {
                "$ref": "Operation"
              },
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/service.management"
              ]
            }
          }
        },
        "projectSettings": {
          "methods": {
            "get": {
              "id": "servicemanagement.services.projectSettings.get",
              "path": "v1/services/{serviceName}/projectSettings/{consumerProjectId}",
              "flatPath": "v1/services/{serviceName}/projectSettings/{consumerProjectId}",
              "httpMethod": "GET",
              "description": "Retrieves the settings that control the specified consumer project's usage\nof the service.",
              "parameters": {
                "serviceName": {
                  "description": "The name of the service.  See the `ServiceManager` overview for naming\nrequirements.  For example: `example.googleapis.com`.",
                  "location": "path",
                  "required": true,
                  "type": "string"
                },
                "consumerProjectId": {
                  "description": "The project ID of the consumer.",
                  "location": "path",
                  "required": true,
                  "type": "string"
                },
                "expand": {
                  "description": "Fields to expand in any results.  By default, the following fields\nare not present in the result:\n- `operations`\n- `quota_usage`",
                  "location": "query",
                  "type": "string",
                  "format": "google-fieldmask"
                },
                "view": {
                  "description": "Request only the fields for the specified view.",
                  "location": "query",
                  "type": "string",
                  "enum": [
                    "PROJECT_SETTINGS_VIEW_UNSPECIFIED",
                    "CONSUMER_VIEW",
                    "PRODUCER_VIEW",
                    "ALL"
                  ]
                }
              },
              "parameterOrder": [
                "serviceName",
                "consumerProjectId"
              ],
              "response": {
                "$ref": "ProjectSettings"
              },
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/service.management"
              ]
            },
            "update": {
              "id": "servicemanagement.services.projectSettings.update",
              "path": "v1/services/{serviceName}/projectSettings/{consumerProjectId}",
              "flatPath": "v1/services/{serviceName}/projectSettings/{consumerProjectId}",
              "httpMethod": "PUT",
              "description": "NOTE: Currently unsupported.  Use PatchProjectSettings instead.\n\nUpdates the settings that control the specified consumer project's usage\nof the service.  Attempts to update a field not controlled by the caller\nwill result in an access denied error.\n\nOperation<response: ProjectSettings>",
              "parameters": {
                "serviceName": {
                  "description": "The name of the service.  See the `ServiceManager` overview for naming\nrequirements.  For example: `example.googleapis.com`.",
                  "location": "path",
                  "required": true,
                  "type": "string"
                },
                "consumerProjectId": {
                  "description": "The project ID of the consumer.",
                  "location": "path",
                  "required": true,
                  "type": "string"
                }
              },
              "parameterOrder": [
                "serviceName",
                "consumerProjectId"
              ],
              "request": {
                "$ref": "ProjectSettings"
              },
              "response": {
                "$ref": "Operation"
              },
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/service.management"
              ]
            },
            "patch": {
              "id": "servicemanagement.services.projectSettings.patch",
              "path": "v1/services/{serviceName}/projectSettings/{consumerProjectId}",
              "flatPath": "v1/services/{serviceName}/projectSettings/{consumerProjectId}",
              "httpMethod": "PATCH",
              "description": "Updates specified subset of the settings that control the specified\nconsumer project's usage of the service.  Attempts to update a field not\ncontrolled by the caller will result in an access denied error.\n\nOperation<response: ProjectSettings>",
              "parameters": {
                "serviceName": {
                  "description": "The name of the service.  See the `ServiceManager` overview for naming\nrequirements.  For example: `example.googleapis.com`.",
                  "location": "path",
                  "required": true,
                  "type": "string"
                },
                "consumerProjectId": {
                  "description": "The project ID of the consumer.",
                  "location": "path",
                  "required": true,
                  "type": "string"
                },
                "updateMask": {
                  "description": "The field mask specifying which fields are to be updated.",
                  "location": "query",
                  "type": "string",
                  "format": "google-fieldmask"
                }
              },
              "parameterOrder": [
                "serviceName",
                "consumerProjectId"
              ],
              "request": {
                "$ref": "ProjectSettings"
              },
              "response": {
                "$ref": "Operation"
              },
              "scopes": [
                "https://www.googleapis.com/auth/cloud-platform",
                "https://www.googleapis.com/auth/service.management"
              ]
            }
          }
        }
      }
    },
    "v1": {
      "methods": {
        "convertConfig": {
          "id": "servicemanagement.convertConfig",
          "path": "v1:convertConfig",
          "flatPath": "v1:convertConfig",
          "httpMethod": "POST",
          "description": "DEPRECATED. `SubmitConfigSource` with `validate_only=true` will provide\nconfig conversion moving forward.\n\nConverts an API specification (e.g. Swagger spec) to an\nequivalent `google.api.Service`.",
          "parameters": {
          },
          "parameterOrder": [
          ],
          "request": {
            "$ref": "ConvertConfigRequest"
          },
          "response": {
            "$ref": "ConvertConfigResponse"
          },
          "scopes": [
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/service.management"
          ]
        }
      }
    },
    "operations": {
      "methods": {
        "get": {
          "id": "servicemanagement.operations.get",
          "path": "v1/operations/{operationsId}",
          "flatPath": "v1/operations/{operationsId}",
          "httpMethod": "GET",
          "description": "Gets the latest state of a long-running operation.  Clients can use this\nmethod to poll the operation result at intervals as recommended by the API\nservice.",
          "parameters": {
            "operationsId": {
              "description": "Part of `name`. The name of the operation resource.",
              "location": "path",
              "required": true,
              "type": "string"
            }
          },
          "parameterOrder": [
            "operationsId"
          ],
          "response": {
            "$ref": "Operation"
          },
          "scopes": [
            "https://www.googleapis.com/auth/cloud-platform",
            "https://www.googleapis.com/auth/service.management"
          ]
        }
      }
    }
  },
  "basePath": ""
}
