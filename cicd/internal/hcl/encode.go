package hcl

import (
	"bytes"
	"fmt"
	"github.com/hashicorp/hcl/v2/hclsyntax"
	"github.com/hashicorp/hcl/v2/hclwrite"
	tfjson "github.com/hashicorp/terraform-json"
	"github.com/zclconf/go-cty/cty"
	"io"
	"time"
)

const (
	parametersAttrName = "parameters"
	doNotEdit          = "# Autogenerated file. Do not edit."
	licenseFmt         = `
#
# Copyright (C) %s Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.
#
`
)

var (
	license = fmt.Sprintf(licenseFmt, time.Now().Format("2006"))
	skip    = map[string]struct{}{
		"id": {},
	}
)

type Encoder struct {
	resourceKey string
	w           io.Writer
	f           *hclwrite.File
	body        *hclwrite.Body
}

func NewEncoder(resourceKey string, w io.Writer) *Encoder {
	f := hclwrite.NewEmptyFile()
	body := f.Body()
	return &Encoder{
		resourceKey: resourceKey,
		w:           w,
		f:           f,
		body:        body,
	}
}

func (enc *Encoder) Encode(schema *tfjson.ProviderSchema) error {
	enc.formatHeader()
	if err := enc.formatBody(schema); err != nil {
		return err
	}

	b := enc.f.Bytes()
	b = normalize(b)
	buf := bytes.NewBuffer(b)
	_, err := io.Copy(enc.w, buf)
	return err
}

func (enc *Encoder) formatHeader() {
	enc.body.AppendUnstructuredTokens(hclwrite.Tokens{
		{
			Type:  hclsyntax.TokenComment,
			Bytes: []byte(license),
		},
	})
	enc.body.AppendNewline()

	enc.body.AppendUnstructuredTokens(hclwrite.Tokens{
		{
			Type:  hclsyntax.TokenComment,
			Bytes: []byte(doNotEdit),
		},
	})
	enc.body.AppendNewline()
}

func (enc *Encoder) formatBody(schema *tfjson.ProviderSchema) error {
	resource, ok := schema.ResourceSchemas[enc.resourceKey]
	if !ok {
		return fmt.Errorf("schema does not contain resource: %s", enc.resourceKey)
	}

	enc.formatParameters()

	if err := enc.formatVariables(resource); err != nil {
		return err
	}

	enc.formatResource(enc.resourceKey, resource)

	return nil
}

func (enc *Encoder) formatVariables(resource *tfjson.Schema) error {
	if resource.Block == nil {
		return fmt.Errorf("resource.Block is nil for %s", enc.resourceKey)
	}

	for k, v := range resource.Block.Attributes {
		enc.formatVariable(k, v)
	}

	return nil
}

func (enc *Encoder) formatParameters() {
	enc.formatLines(nil,
		`<#list parameters as variable>`,
		`variable "${variable.name}" {`,
		`  type = ${variable.type?lower_case}`,
		`  description = "${variable.description}"`,
		`  <#if variable.defaultValue??>`,
		`  <#if variable.type == "STRING">default = "${variable.defaultValue}"<#else>default = ${variable.defaultValue}</#if>`,
		`  </#if>`,
		`}`,
		`</#list>`,
	)

	enc.body.AppendNewline()
}

func (enc *Encoder) formatLines(body *hclwrite.Body, lines ...string) {
	if body == nil {
		body = enc.body
	}
	for _, line := range lines {
		body.AppendUnstructuredTokens(hclwrite.Tokens{
			{
				Type:  hclsyntax.TokenNewline,
				Bytes: []byte(line),
			},
		})
		body.AppendNewline()
	}
}

func (enc *Encoder) formatVariable(name string, attr *tfjson.SchemaAttribute) {
	if name == parametersAttrName {
		return
	}
	if attr.Computed {
		return
	}
	if attr.Deprecated {
		return
	}

	block := enc.body.AppendNewBlock("variable", []string{name})
	body := block.Body()
	typeName := extractTypeName(attr)

	body.SetAttributeRaw("type", hclwrite.Tokens{
		{
			Type:  hclsyntax.TokenIdent,
			Bytes: []byte(typeName),
		},
	})

	body.SetAttributeValue("description", cty.StringVal(attr.Description))

	if attr.Optional {
		defaultValue := extractDefaultValue(attr)
		body.SetAttributeRaw("default", hclwrite.Tokens{
			{
				Type:  hclsyntax.TokenIdent,
				Bytes: []byte(defaultValue),
			},
		})
	}

	if attr.Sensitive {
		body.SetAttributeValue("sensitive", cty.BoolVal(true))
	}

	enc.body.AppendNewline()
}

func (enc *Encoder) formatResource(name string, resource *tfjson.Schema) {
	block := enc.body.AppendNewBlock("resource", []string{name, "job"})
	body := block.Body()

	enc.formatResourceParameters(body)

	for k, attr := range resource.Block.Attributes {
		if k == parametersAttrName {
			continue
		}
		if attr.Computed {
			continue
		}
		if attr.Deprecated {
			continue
		}

		body.SetAttributeRaw(k, hclwrite.Tokens{
			{
				Type:  hclsyntax.TokenIdent,
				Bytes: []byte(fmt.Sprintf("var.%s", k)),
			},
		})
	}
	enc.body.AppendNewline()
}

func (enc *Encoder) formatResourceParameters(body *hclwrite.Body) {
	enc.formatLines(body,
		`  parameters = {`,
		`<#list parameters as variable>`,
		`    ${variable.name} = <#if variable.type == "STRING">var.${variable.name}<#else>tostring(var.${variable.name})</#if>`,
		`</#list>`,
		`  }`,
	)
	body.AppendNewline()
}

func normalize(b []byte) []byte {
	return bytes.ReplaceAll(b, []byte("$$"), []byte("$"))
}

func extractTypeName(attr *tfjson.SchemaAttribute) string {
	typeName := attr.AttributeType.FriendlyName()
	attrType := attr.AttributeType

	if attrType.IsMapType() {
		typeName = fmt.Sprintf("map(%s)", attr.AttributeType.ElementType().FriendlyName())
	}
	if attrType.IsListType() {
		typeName = fmt.Sprintf("list(%s)", attr.AttributeType.ElementType().FriendlyName())
	}
	if attrType.IsSetType() {
		typeName = fmt.Sprintf("set(%s)", attr.AttributeType.ElementType().FriendlyName())
	}

	return typeName
}

func extractDefaultValue(attr *tfjson.SchemaAttribute) string {
	attrType := attr.AttributeType
	if attrType.IsMapType() {
		return "{}"
	}
	if attrType.IsListType() || attrType.IsSetType() {
		return "[]"
	}
	return "null"
}
