/*
 * Copyright (C) 2024 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.google.cloud.teleport.bigtable;

import static com.datastax.oss.driver.api.querybuilder.QueryBuilder.selectFrom;

import com.datastax.oss.driver.api.querybuilder.select.Select;
import com.google.cloud.teleport.util.GCSAwareValueProvider;
import com.google.cloud.teleport.util.ValueProcessor;
import org.apache.beam.sdk.options.ValueProvider;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/** This class processes a Cassandra column schema string into a writetime query string. */
class CassandraColumnSchemaProcessor implements ValueProcessor {
  private static final Logger LOG = LoggerFactory.getLogger(CassandraColumnSchemaProcessor.class);

  @Override
  public String process(String fileString) {
    LOG.debug("Cassandra column schema provided, parsing file string: " + fileString);
    // Parse Cassandra column schema to generate writetime-enriched CassandraIO query.
    CassandraColumnSchema schema = new CassandraColumnSchema(fileString);

    // Add writetime query to CassandraIO.
    String writetimeQuery = schema.createWritetimeQuery();
    LOG.debug("Write time query generated: " + writetimeQuery);
    return writetimeQuery;
  }
}

/**
 * Value provider that explicitly looks for a Cassandra column schema file and provides either a
 * selectAll query or selectAll+writetime query.
 */
public class CassandraWritetimeQueryProvider extends GCSAwareValueProvider {
  private static final Logger LOG = LoggerFactory.getLogger(CassandraWritetimeQueryProvider.class);
  private final ValueProvider<String> cassandraKeyspace;
  private final ValueProvider<String> cassandraTable;

  private transient volatile String query;

  public CassandraWritetimeQueryProvider(
      ValueProvider<String> cassandraColumnSchema,
      ValueProvider<String> cassandraKeyspace,
      ValueProvider<String> cassandraTable) {
    // Uses GCSAwareValueProvider and resolves the GCS file with the schema processor.
    super(cassandraColumnSchema, new CassandraColumnSchemaProcessor());
    this.cassandraKeyspace = cassandraKeyspace;
    this.cassandraTable = cassandraTable;
  }

  /**
   * Provides either a selectAll statement or selectAll+writeTime statement. This is necessary in
   * order for CassandraIO to query dynamically.
   *
   * @return String CQL query string.
   */
  @Override
  public synchronized String get() {
    // Prioritize returning a previously generated query.
    if (query != null) {
      return query;
    }
    // If query is not generated, then generate it. It could either get generated by:
    // 1. super.get() - that gets the GCS value and then resolves it with the processor, or
    // 2. a generic selectAll query.
    if (super.get() != null) {
      query = super.get();
    } else {
      // Construct select-all statement in case column schema is not provided.
      Select selectAll = selectFrom(cassandraKeyspace.get(), cassandraTable.get()).all();

      LOG.debug("No column schema provided, returning selectAll query " + selectAll.asCql());
      query = selectAll.asCql();
    }
    return query;
  }

  @Override
  public boolean isAccessible() {
    return !query.isBlank();
  }

  @Override
  public String toString() {
    return query;
  }
}
